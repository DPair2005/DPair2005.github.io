 

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="/css/main.css">
  <link rel="stylesheet" type="text/css" href="/css/art.css">
  <link rel="icon" type="images/png" href="/images/favicon.png">
  <script src="/js/element.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.4.0/build/styles/atom-one-light.min.css">
  <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.4.0/build/highlight.min.js"></script>
</head>

<body>
  <script>
    window.onload = function() {
      loadMath();
      drawSaying();
      hljs.configure({ tabReplace: '  ' });
      hljs.initHighlighting()
    }
  </script>

  <div class="content">
    <div class="sidebar" id="sidebar">
      <title>
          Ynoi 做题记录 II
      </title>
      <script>
    SaveBackground()
  </script>
  <div class="sidebar-title">
    <p style="font-weight: bold; font-size: 25px; font-family: 'ZCOOL XiaoWei';" onclick="drawSaying()"> 
  
  DPairの非自制 blog
      <HR align="center" style="width: 200px;">
    </p>
      <div font="" style="text-align: center; font-size: 18px; font-family: 'ZCOOL XiaoWei';" class="sayingtype" id="sayingtype"> </div>
      <div font="" style="text-align: center; font-size: 6px;"> 　 </div>
    <div class="saying" id="saying"> </div>
  </div>
  <div class="sidebar-body">
  
    <div class="sidebar-content">
      <ul class = "sidebar-menu">
        <a href="/">
          <li class="list-item sidebar-menu-item" id="sidebar-content-home">
            Home
          </li>
        </a>
        <a href="/articles">
          <li class="list-item sidebar-menu-item" id="sidebar-content-articles">
            Articles
          </li>
        </a>
        <a href="/transit">
            <li class="list-item sidebar-menu-item" id="sidebar-content-Transit"
            style="background: #e5e5e5">
            Transit
        </li>
        </a>
        <a href="/tags">
          <li class="list-item sidebar-menu-item" id="sidebar-content-tags">
            Tags
          </li>
        </a>
      </ul>
    </div>
    <div class="sidebar-about">
      <div style="text-align: center; font-size: 16px;"> About DPair </div>
      <HR align="center">
      <div style="margin: 2 auto; width: min-content" onclick="NextBackground()">
        <img class="avatar" alt="DPair" src="/images/avatar.png">
      </div>
      <ul class="sidebar-links">
  
  <li class="sidebar-links-item">
      <a href="https://www.luogu.com.cn/blog/DPair2005/" class="friend-link"> 
        luogu blog 
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://codeforces.com/profile/DPair" class="friend-link"> 
        Codeforces 
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://atcoder.jp/users/DPair" class="friend-link"> 
        AtCoder 
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://gitee.com/DPair" class="friend-link"> 
        gitee 
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://github.com/DPair2005" class="friend-link"> 
        github 
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="mailto:DPair2005@163.com" class="friend-link"> 
        mail 
      </a>
    </li>
  
      </ul>
    </div>
  
    <ul class="sidebar-links">
      <div style="text-align: center; font-size: 16px;"> Friend Links </div>
      <HR align="center">
      
  <li class="sidebar-links-item">
      <a href="https://www.luogu.com.cn/user/140572" class="friend-link"> 
        DSair
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://coderoj.gitee.io/" class="friend-link"> 
        Jacderzhang's blog
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://xyix.gitee.io/" class="friend-link"> 
        xYix's blog
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://www.cnblogs.com/Flying2018/" class="friend-link"> 
        Flying2018's blog
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://www.cnblogs.com/-Wallace-/" class="friend-link"> 
        _Wallace_'s blog
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://www.cnblogs.com/Point-King/" class="friend-link"> 
        Point_King's blog
      </a>
    </li>
  
    </ul>
  
  </div>
  
    </div>

    <div class="post" id="post">
      <h1 id="ynoi-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-ii">Ynoi 做题记录 II</h1>
<blockquote>
<p>“Ynoi难度低，联赛前选学。”</p>
<p>—— XXY</p>
</blockquote>
<p>由于我做过的 $\text{Ynoi}$ 题稍微有些多了，再放在同一个页面里面渲染会非常慢，因此分开放。</p>
<p>21、<a href="https://www.luogu.com.cn/problem/P6105">P6105 [Ynoi2010] y-fast trie</a></p>
<p>标签：STL、小力分讨、平衡树</p>
<p>AFO之后发现自己完全不会数据结构了。。。</p>
<p>首先显然我们可以把每一个数都对 $C$ 取模，然后把集合变成一个可重集，这里比较建议用 <code>std :: map</code> 来实现。</p>
<p>然后显然问题被分成了两部分，一部分是 $x + y \ge C$ ，一部分是 $x + y &lt; C$ （懂我意思吧）。</p>
<p>前一部分，我们显然取最大值和次大值最优，这个应该不需要多解释。</p>
<p>那么就看两数之和小于 $C$ 的部分，然后与第一部分取个 <code>max</code> 即可。</p>
<p>首先我们称一个数的 “最优匹配数”，为集合中与它之和小于 $C$ 且最大的那一个数。称一对互为 “最优匹配数” 的数为一个 “最优匹配”，其权值为两数之和。</p>
<p>那么显然对于一个数，我们要存它在集合中的出现次数，然后我们就可以利用这一部分数据和二分（或<code>lower_bound</code>） 求出它的最优匹配了，这里是 $O(\log n)$ 的，这个可以用 <code>map</code> 实现。</p>
<p>并且我们要实时知道该序列最优的“最优匹配”的权值，于是我们再开一个 <code>map</code> 维护所有“最优匹配”，这里只维护权值即可，不需要维护具体数字，原因与后面的实现有关。</p>
<p>那么我们现在就要考虑怎么维护这两个东西。</p>
<p>首先第一个很好维护，有手就行。</p>
<p>考虑怎么实时维护出所有 “最优匹配” 。</p>
<p>但注意到我们实际只有最大值正确这一个要求，所以我们只需要考虑怎样维护能够保证最大值一定出现且不出现的一定不会出现。</p>
<p>一种很 naive 的想法是每一次插入的时候顺带着插入这个数所对应的“最优匹配”，但是删除的时候显然会炸掉。</p>
<p>所以我们要考虑怎样使得一个数最多被使用一次。</p>
<p>那么这一次显然要是最优的。</p>
<p>也就是说，不优的那一次要被我们剔除在外，不作保存，等删除的时候再恢复回来。</p>
<p>于是我们有了这道题的一个大体思路。</p>
<p>那么我们来考虑一下对于一个数怎样才是更优的，并且这个不优解还能恢复回来。</p>
<p>首先假设我们插入的是 $x$ ，搜到它的“最优匹配数”是 $b$ 。</p>
<p>然而此时 $x$ 还没被插入进去，所以我们再搜 $b$ ，搜出最优匹配是 $c$ （<del>注意大小写</del>）。</p>
<p>当然由于这是个可重集， $c=x$ 可能成立，这里不去考虑。</p>
<p>显然若 $c \ge x$ ， $x$ 不可能进入最优匹配，故直接退出。</p>
<p>接下来考虑 $c &lt; x$ 的情况。</p>
<p>那么显然我们可以考虑把 $(x, b)$ 加进去了，但是删不删 $(b, c)$ 还得讨论 $(b, c)$ 在不在集合内。</p>
<p>于是我们搜一下 $c$ 的最优匹配 $d$ ，判断 $b=d$ 是否成立即可判断 $(b, c)$ 是否在集合内了。</p>
<p>删除其实同理，我们只需要把原来的插入转化为删除，然后假装我们要插入，看看会发生什么变化，然后把这些变化一一撤销即可。</p>
<p>于是就做完了，复杂度为大常数的 $O(n\log n)$</p>
<p>22、<a href="https://www.luogu.com.cn/problem/P4690">P4690 [Ynoi2016] 镜中的昆虫</a></p>
<p>标签：珂朵莉树、复杂度分析、二维数点、CDQ分治</p>
<p>首先我们考虑单点修改区间数颜色怎么做。</p>
<p><del>不要跟我说什么带修莫队。</del></p>
<p>有一个十分<del>金典</del>经典的套路是记录每一个元素本身以及它的同色前驱的位置，转化为一个二维数点，前驱不在区间内且本身在区间内的点可以产生 $1$ 的贡献，这个用 CDQ分治然后差分一下什么的就行了（没想到吧这是我第一次用CDQ分治二维数点）。</p>
<p>考虑单点修改，我们修改这个位置的前驱，前驱的后继，后继的前驱就行了，然后可以通过加一维时间以及负权点来实现修改。</p>
<p><del>突然感觉 CDQ 有点强大的啊。</del></p>
<p>然后我们考虑区间修改。</p>
<p>区间推平？我会暴力珂朵莉树！</p>
<p>如果你是暴力数颜色的话，你就只能拿 $10\text{pts}$ 。 </p>
<p>我们考虑把两种方法结合起来。</p>
<p>这时候有人要问了，这样子的话修改的点数难道不是 $O(nm)$ 的吗？</p>
<p>考虑对于一次推平，我们在珂朵莉树上的操作是删除一堆同色区间然后插入一个大同色区间，不难发现一个同色中只有 $l$ 节点的位置的前驱不是它本身的“位置 - 1”。</p>
<p>于是我们删除的这些小区间中，我们只需要修改每一个小区间的 $l$ 节点即可！</p>
<p>显然我们每修改一个 $l$ ，小区间就减少一个，而且由于一个小区间同色，需要修改的“前驱的后继”和“后继的前驱”也都只有一个，而且事实上这里同样用 <code>std :: set</code> 维护的话对于每一种颜色可以方便地求出后继，也就是说直接修改后继就行了。</p>
<p>所以每一个区间产生的贡献是 $O(1)$ 的，于是暴力修改的点数变化量是 $O(n+m)$ 。</p>
<p>那么就转化成了若干单点修改和矩形查询，CDQ分治二维数点即可。</p>
<p>本题 $n, m$ 同阶，所以最终复杂度 $O(n\log^2 n)$ 。</p>
<p>23、<a href="https://www.luogu.com.cn/problem/P3934">P3934 [Ynoi2016] 炸脖龙 I</a></p>
<p>标签：扩展欧拉定理</p>
<p>这道题对数据结构要求为 $0$ 。。。</p>
<p>首先连续取幂考虑扩展欧拉定理。</p>
<p>可以直接理解为 </p>
<script type="math/tex; mode=display">
a^p=a^{p\mod \phi(m)+[p\ge \phi(m)]\times \phi(m)} \mod m</script><p>然后不难发现每一次取 $\phi()$ 都至少减少二分之一。</p>
<p>所以可以直接暴力，从 $[l, r]$ 开始递归处理，那么我们需要做的就是判断 $f(l + 1, r)$ 是否 $\ge \phi(m)$ 。</p>
<p>显然若出现 $1$ 则可以直接返回。</p>
<p>若没有 $1$ ，则往后 $5$ 个以内必然超过 $\phi(m)$ ，因为 $2^{2^{2^{2^2}}}$ 是很大的（自己算算）。</p>
<p>所以往后判断 $5$ 个就可以得到是否取模，而且不难发现，不取模的情况下后面有效数字必然 $&lt; 5$ 个，可以直接暴力，否则递归下来也就最多 $\log$ 层。</p>
<p>可能还有一些实现上的细节。</p>
<p>树状数组沦为工具人。</p>
<p>复杂度 $O(n\log^2 n)$ ，<del>我们假装 $n, p$ 同阶好了</del>。</p>
<p>真要说的话似乎是 $O(n\log n(\log p+\log n))$ ？算了算了当同阶吧（（</p>
<p>24、<a href="https://www.luogu.com.cn/problem/P6019">P6019 [Ynoi2010] Brodal queue</a></p>
<p>标签：分块</p>
<p>区间推平区间相等二元组对数。</p>
<p>首先我们考虑区间相等的二元组的对数若没有修改怎么求。</p>
<p>莫队太没前途了，我们考虑分块。</p>
<p>一种分块的思路是最基础的在线化莫队，即记录任意两块之间的答案，然后向两边扩展，但这显然不好修改。</p>
<p>所以我们要考虑如何维护容易修改的信息。</p>
<p>不难发现，一般来说前缀和比较好维护，因为我们原先难以维护的原因在于要修改 <strong>所有包含某一个块</strong> 的 <strong>块构成的区间</strong> ，而这一部分复杂度是比较大的，这时的均摊就是要带一个 $n^\frac{2}{3}$ 的复杂度（即带修莫队）。</p>
<p>而前缀和修改一个后缀就行了，复杂度是 $n^{1\over 2}$ ，比较优秀。</p>
<p>然后考虑把这道题转化为前缀和怎么搞。</p>
<p>我们先考虑单点修改。</p>
<p>不难发现我们散块是很好处理的，所以接下来所有东西 <strong>都以块为单位</strong> 。</p>
<p>首先二元组对数即 ：
（ <code>cnt[x]</code> 表示区间内 <code>x</code> 的个数）</p>
<script type="math/tex; mode=display">
\sum_x cnt[x](cnt[x]-1)/2</script><p>这个东西显然可以转化成：</p>
<script type="math/tex; mode=display">
((\sum_x cnt[x]^2)-len)/2</script><p><del>自证不难</del></p>
<p>那么我们维护这个式子即可：</p>
<script type="math/tex; mode=display">
\sum_x cnt[x]^2</script><p>这样一来就阳间多了。</p>
<p>接下来我们考虑用一个前缀和之差的形式表示这个值。</p>
<p>显然为 ：
（ <code>b</code> 表示前缀和）</p>
<script type="math/tex; mode=display">
(b[r]-b[l-1])^2=b[r]^2+b[l-1]^2-2b[r]b[l-1]</script><p>于是我们需要维护一个前缀和的平方。</p>
<p>不难发现这很容易做到，并且这东西对于每一个 $x$ 互相独立，故可以 <strong>直接维护其和</strong>，设为 $s[]$ 数组。</p>
<p>然后我们就只需要维护 $-2b[r]b[l-1]$ 这个东西就行了。</p>
<p>不妨设 $f(i, j)=\sum_{x} b[i]b[j]$</p>
<p>那么我们考虑怎么维护这个东西。</p>
<p>不难发现，当一个块 $k$ 被修改时，会出现三类 $(i, j)$，我们假设 $k$ 内的 $x$ 被修改了 $y$ ，并且这一部分允许 $O(\sqrt{n})$ 的复杂度。</p>
<p>我们不妨设 $b[i], b[j]$ 均对于 $x$。</p>
<ul>
<li>$i &lt; k, j &lt; k$ 显然没必要动。</li>
<li>$i &lt; k, j\ge k$ 这一部分的修改量为 $b[i](b[j]+y)-b[i]b[j]=b[i]y$ ，故枚举 $i$ 然后用差分的思想修改即可，因为我们查询时显然也可以带 $\sqrt{n}$。</li>
<li>$i \ge k, j \ge k$ 这一部分的修改量为 $(b[i]+y)(b[j]+y)-b[i][j]=b[i]y+b[j]y+y^2$ ，同理修改即可，不做赘述。</li>
</ul>
<p>然后查询就十分方便了，先整块直接用 $f, s$ 两个东西算出来，然后散块暴力就行了。</p>
<p>然后是区间推平。</p>
<p>我们可以每一个块打一个 $tag$ 表示是否被整块推平，那么整块推有 $tag$ 的块时就是修改次数就是 $O(1)$ 的，因为不难发现我们上述单点修改适用于一个块内多个 <strong>同色元素</strong> 被 <strong>同时修改</strong> 的情况。</p>
<p>然后散块的话我们可以考虑对 <strong>每一种颜色</strong> 暴力修改，因为这样的话修改次数就是区间内的颜色数，而扫描散块的复杂度显然是 $O(\sqrt{n})$ 所以不需要过多考虑。</p>
<p>那么我们每一次修改最多增加 $O(1)$ 个无 $tag$ 的块，并且这里面的颜色数是极其有限的，最终复杂度是正确的。</p>
<p>然后我们处理整块的时候，无 $tag$ 的块显然可以暴力处理，这里的复杂度正确性上面已经说过，有 $tag$ 的块无需修改直接 $O(1)$ 打 $tag$ 即可，在询问的时候当作 <strong>一次性加入多个相同的数</strong> 处理即可，不然会导致复杂度错误。</p>
<p>最后复杂度 $O((n+m)\sqrt{n})$ ，空间复杂度 $O(n\sqrt{n})$ 。</p>
<p>25、<a href="https://www.luogu.com.cn/problem/P7447">P7447 [Ynoi2007] rgxsxrs</a></p>
<p>标签：polylogの分块、空间の优化、<strong>空间卡常</strong></p>
<p>首先这东西咋看之下像是一个第二分块。</p>
<p>然后一看值域人傻了，发现这不是第二分块的做法能承受的值域。</p>
<p>所以我们考虑一个 <strong>与值域无关</strong> 或 <strong>log值域</strong> 的做法，本题是后者。</p>
<p>这题不难发现是一复杂度分析的题目，我们考虑怎样使得它的复杂度正确。</p>
<p>首先有一种 naive 的想法就是对值域分块，假设 <strong>块数</strong> 为 $B$ 。每一个块开一棵 <strong>序列线段树</strong> ，每一个结点记录一个区间内的 $\max, \min, \sum$ 还有出现的数的个数，显然这些信息可以 $O(B\log n)$ 查询并合并得到。</p>
<p>然后每一次修改，我们考虑会出现 <strong>值域块之间数值的移动</strong> ，每一个值会至少移动 $O(B)$ 次，所以均摊下来就是 $O(Bn)$ 次查找。由于我们在线段树上修改，我们 <strong>每次</strong> 找一个数的复杂度应该是 $O(\log n)$ ，所以 <strong>块间移动</strong> 这部分的总复杂度是 $O(Bn\log n)$ 的。</p>
<p>但是这有一个前提，那就是我们找一个数的时候要能够 <strong>准确找到所有会被移动的数</strong> ，即我们不会在线段树上往下查询到一定深度了，才发现这个区间里没有会被移动的数。</p>
<p>然而我们不可能详细记录区间信息，我们还是只记录 $\min, \max$ ，现在就是要求我们通过这两个信息判断一个结点内是否有需要被修改的数。</p>
<p>这里我们可以分类讨论，首先假设我们修改的是 $x$，当前结点是 $\min = l, \max = r$ （注意这里是最大值最小值）。</p>
<p>我们显然可以分三类：</p>
<ol>
<li>$x \ge r$ 显然对于这一个区间什么都不会发生，直接退出。</li>
<li>$x &lt; l$ 这里我们显然只需要考虑 $l$ 是否会掉到其他的块里面。如果会，那么就暴力往下遍历，不难发现这样一定会最终遍历到需要 <strong>块间移动</strong> 的位置；如果不会，我们就给这个区间打上一个区间减的 $tag$ 就行了。</li>
<li>$x \in [l, r)$ 这里就比较难办了，不难发现 $[l, x]$ 之间的数并不会发生改变，而且仅凭一个 $r$ 并不能完全判断这个区间中是否有会掉到其他块内去的数，因为可能 $r$ 并不会掉到其他块中，但存在一个 $(x, r)$ 之间的数会掉到下一个块中，而且这样的数是否存在我们并不知道。</li>
</ol>
<p>那么我们考虑怎么处理 $3$ 问题，我们回头看看，我们有什么地方还有改动的空间呢？</p>
<p>不难发现我们还没有定块长，而且这道题的复杂度似乎和块长没有关系，故 <strong>块数越少越好</strong> 。</p>
<p>并且，我们需要使得 $3$ 情况可以被判断，一个有效的思路是 <strong>一旦</strong> $x \in [l, r)$ <strong>成立，那么这个块一定需要被修改</strong> 。</p>
<p>即我们需要满足 $r-x&lt;l$ 对 <strong>同一块内</strong> 一切 $(l, r)$ 的二元组成立。</p>
<p>不难发现 $r &lt; l + x$ ，故 $r_{\max}=l+x-1$ ，又因为我们要保证这个式子对于任意 $x\in [l, r)$ 成立，故取最劣情况 $x=l$ 即 $r_{\max}=2l-1$ 。由于我们要使得块数尽可能少，我们取 $r=r_{\max}=2l-1$ 。</p>
<p>所以我们进行的就是类似 <strong>倍增</strong> 的 <strong>不均匀分块</strong> ，这个思路是真的妙。</p>
<p>不难发现块数 $B= \log V$ （ $V$ 为值域），所以总复杂度为 $O((n+m)\log n\log V)$ ，空间复杂度 $O(n\log V)$ 。</p>
<p><del>没错，一道分块题拥有了 polylog 的复杂度，没想到吧（（</del></p>
<p>但是赛后 lxl 卡空间了。。。毒瘤石锤了。</p>
<p>我们发现空间会炸的原因在于 $B$ 比较大，所以我们不得不把 $B$ 变小。</p>
<p>但是根据刚才的分析，这不已经是 $B$ 的最小值了吗？</p>
<p>此时就需要我们牺牲时间换空间了。</p>
<p>不难发现，我们之前讨论 $3$ 情况时直接钦定了 $r &lt; l + x$ ，因为这样 $r$ 不会被多算。</p>
<p>那么，如果我们允许多算呢？</p>
<p>不难发现，若 $r \ge l + x$ ，那么每一次 <strong>多算</strong> $r$ 都会产生 $O(\log n)$ 的复杂度。</p>
<p>但是不难发现，每一次 <strong>多算</strong> ，$r$ 都会减少 $x$ ，而 $x$ 至少也是 $l$ 。</p>
<p>所以我们假设 $r &lt; bl$ 即取 $r=bl-1$ ，此时 $B=\log_b V$ ，空间得到了优化。但是时间上要多一个 $O(b)$ 的常数，不过同样的我们可以少跳几次，故时空复杂度分别为 $O(Bb(n+m)\log n)$ ，$O(Bn)$ 。</p>
<p>简单算一算就会发现 $b=8$ 比较合适，时间退化不是很大的情况下把空间缩小到了原来的 $1\over 3$ 的样子。</p>
<p>但是这么一算还是要 $500 \text{MB}$ 的样子，不太行。</p>
<p>不过我们意识到我们用的数据结构是线段树，我们可以采取 <strong>小于某个阈值即暴力</strong> 的操作手段来进行空间优化，具体来说就是一个叶子结点表示的是一段长度为一个阈值 $k$ 的区间而非一个长度为 $1$ 的区间。</p>
<p>不难发现，$k$ 每扩大一倍，总空间就缩小一半（因为叶子结点被删没了，故一半结点没了），故 $k$ 足够大时空间会大大缩小。</p>
<p>发现 $k=16=2^4$ 时，总空间也除以 $16$ ，然后就没什么问题了。而且由于本来线段树跑最后几层也需要一定的常数，故时间上退化不会非常严重。</p>
<p><del>然而实测</del> $k=32$ <del>时效率更高（（</del></p>
<p>另外，如果使用动态开点的话，可能还要多维护一下左右儿子的标号，所以本题中对空间优化意义不大，故不选用。</p>
<p><del>这东西复杂度算起来感觉会非常屎，就当是个优化吧（（</del></p>
<p><del>据说叫什么 “底层分块” ？</del></p>
<p>26、<a href="https://www.luogu.com.cn/problem/P7446">P7446 [Ynoi2007] rfplca</a></p>
<p>标签：分块</p>
<p>比较简单的一道分块题。</p>
<p>感觉和 <a href="https://www.luogu.com.cn/problem/P3203">P3203 [HNOI2010]弹飞绵羊</a> 有点像。</p>
<p>首先考虑一遍所有 polylog 或更低的求 LCA 的方法，发现在这道题好像都用不出来，于是考虑根号做法。</p>
<p>我们对序列分块。</p>
<p>为了使得我们能够快速查询，我们在查询 LCA 时每一步都要 <strong>跳至少一个块</strong>，故考虑维护每一个点 <strong>出块</strong> 后的第一个祖先和真实的祖先。</p>
<p>假设某一个块内所有点出块后的第一个祖先就是真实的祖先，由于祖先 <strong>只减不加</strong>，故后面所有状态这个块内的祖先 <strong>全部出块</strong>，因此我们维护时直接打 tag 即可，每一个块 $O(1)$ 。</p>
<p>并且不难发现每个块被修改至多 $\sqrt{n}$ 次之后必然会达到全部出块的状态。</p>
<p>因此，这 $\sqrt{n}$ 次修改允许 $O(\sqrt{n})$ 的复杂度，即重构。</p>
<p>重构的时候扫一遍这个块，然后每一个点向前连，用类似路径压缩的方法处理即可，十分简单。</p>
<p>故修改复杂度 $O(n\sqrt{n})$ 。</p>
<p>然后找 LCA 的话就用类似倍增的方法暴力跳。这里对于全部出块的块很好处理，但是对于没有全部出块的块可能会出现两点虽然在同一块内，但是其 LCA 不在这一块内的情况，只维护刚才的东西难以在块内判断 LCA 是否在这个块中。</p>
<p>不难发现我们可以在每一次重构的时候顺便维护出每一个元素 <strong>块内最前面的祖先</strong> ，用类似并查集的思路，判断一下这一个是否相同即可，显然这个东西只会在 <strong>没有全部出块</strong> 的块内被用到，而且每一次重构显然可以顺便求出，故不会改变复杂度。</p>
<p>最后状态显然为两个元素的 LCA 在某一个块内，这一部分暴力扫即可。</p>
<p>故询问复杂度 $O(n\sqrt{n})$  。</p>
<p>总时间复杂度 $O(n\sqrt{n})$ ，空间复杂度 $O(n)$ ，可以通过本题，完全不卡常。</p>
<p>27、<a href="https://www.luogu.com.cn/problem/P6018">P6018 [Ynoi2010] Fusion tree</a></p>
<p>标签：Trie</p>
<p>首先有一个极其简单的套路：对于这种距离为 $1$ 的询问，我们可以考虑单独维护父亲，然后对于所有儿子来一个全局修改全局查询的数据结构。</p>
<p>这里我们使用的就是 Trie 。</p>
<p>我们现在要支持的就是一个 <strong>全局+1，单点修改，全局查询异或和</strong> 的一棵 Trie 。</p>
<p>不难发现两个性质：</p>
<ol>
<li>我们这里由于全部都是全局查询，故不关心数值的具体大小关系。</li>
<li>我们全部都是全局修改，并且全局加 $1$ 本质上就是把所有最低位为 $1$ 的数，往上加。</li>
</ol>
<p>那么我们就可以考虑这样一个事情，我们建一棵 <strong>自下而上</strong> 的 Trie ，即从低位向高位建 Trie 这样就可以方便地实现加 $1$ 的操作，因为我们显然可以通过 $0$ 变 $1$ ，然后 $1$ 变 $0$ ，之后递归 $1$ 的操作来完成一次 $+1$ ，并且复杂度是 $O(\log V)$ 的。</p>
<p>这样子的优势在于，我们原本的建 Trie 方式会使得有大量的最低位需要被修改，现在每一位都只会修改一次，故达到了极大的优化。而且由于这道题不关心具体大小关系的性质，这么做是对的。</p>
<p>显然这样我们可以方便地维护出每一个位置的异或和，也可以方便地单点修改。</p>
<p>然后父亲什么的特判一下就行了，至于单点的权值查询什么的打个 tag 就解决了。</p>
<p>复杂度 $O((m+n)\log V)$ ，十分优秀。</p>
<p>28、<a href="https://www.luogu.com.cn/problem/P5609">P5609 [Ynoi2013] 对数据结构的爱</a></p>
<p>标签：线段树、最优化</p>
<p>可能是这一阶段的最后一道额外练习的数据结构了，题目名称十分应景。</p>
<p>首先我们发现这个 $n$ 和这个 $m$ 的范围有一定差距，大胆猜想这道题需要 $O(n\log n)$ 预处理 $O(m\log^2 n)$ 查询。<del>然后你会发现事实就是这样</del></p>
<p>不过这对我们解题似乎没有什么帮助。</p>
<p>于是我们还是数据结构题的经典思路，考虑我们要维护什么东西。</p>
<p>我们可以这样想：</p>
<p>我们一段区间的区间和我们是知道的，然后这段区间的答案显然可以表示成 <strong>原先的区间和减去取模数的一个倍数</strong> 的形式。</p>
<p>那么我们看看这个 <strong>倍数</strong> 能不能被维护出来，不难发现这个东西的实际意义就是 <strong>取模几次</strong> 即 <strong>有几次当前数出现 $\ge p$ 的情况</strong> 。</p>
<p>不难发现，对于某一段区间 $[l, r]$ 这东西只会受到我们在 $[l, r]$ 之前的 <strong>当前数</strong> 的影响，并且这个次数不会大于区间长度。</p>
<p>而且显然，这个次数的值随着 <strong>当前数</strong> 的增加而 <strong>单调递增</strong> ，证明略。</p>
<p>那么这启示我们可以对于线段树上每一个结点开一个 <code>std :: vector</code> ，用来表示 <strong>扫过这段区间后次数为某数所需要的最小数</strong> ，在查询的时候二分一下就可以判断出这个区间对于任意当前数的次数。</p>
<p>这部分是 $O(m\log^2 n)$ 的，然后我们考虑怎么合并两个 <code>vector</code> 。</p>
<p>首先我们不难发现合并之后这个 <code>vector</code> 还是递增的，于是我们可以 $O(len^2)$ 扫描左右儿子来处理出最优方案，这里的最优方案即上文提到的 <strong>最小数</strong> 。</p>
<p>这东西显然是单调的，即对于一组 $l[i], r[j]$ ，它对 $rt[i+j]$ 的贡献显然优于 $l[i+1], r[j-1]$ 的贡献，所以可以 $O(len)$ 双指针直接搞定。</p>
<p>判一下一组 $i, j$ 指针是否合法即可，即通过前者能否到达后者，这个容易判断不作赘述。</p>
<p>所以最终时间复杂度 $O(n\log n + m\log^2 n)$ ，空间复杂度 $O(n\log n)$ ，还有几个小优化，随便加一加就拿最优解了，不赘述。</p>
<p>29、<a href="https://www.luogu.com.cn/problem/P6578">P6578 [Ynoi2019] 魔法少女网站</a></p>
<p>标签：分散层叠算法、分块</p>
<p>$\color{red}{「？？？？第十分块」}$</p>
<p>首先我们看到这种 <strong>“最大值小于”</strong> 的问题，不难想到我们要求的就是和 <strong>“全部元素小于给定数的极长连续段”</strong> 有关的一些信息。</p>
<p>所以我们要维护这些连续段，考虑对序列分块，块长为 $b$ ，我们不妨设 $&gt; x$ 的数为 $1$ , $\le x$ 的数为 $0$ ，那么我们得到的就是一个 $01$ 序列。我们要求的就是每一块的 <strong>块内答案、块的最长全 0 前缀和块的最长全 0 后缀</strong> 的长度。</p>
<p>但是对于不同的 $x$ ，这个序列不同。</p>
<p>不过显然对于某一个块，不同的块内信息最多 $O(b)$ 种，并且每一种对应一个 $x$ 的连续段，不难想到我们可以二分。</p>
<p>然后我们发现，这东西显然可以方便地重构，一次重构也是 $O(b)$ 的。</p>
<p>散块查询显然是 $O(b)$ 的，但是整块需要二分的话查询复杂度为 $O({n\over b}\log b)$ ，这是我们所不能接受的。</p>
<p>我们使用分散层叠算法在线段树上的应用（其实哪怕不知道这个东西往下看也能看懂），即先对于所有 <strong>块</strong> 建立线段树，每一个节点维护一个 <strong>有序序列</strong> 便于二分，其中所有叶子节点（即我们分好的块）维护的就是块内的元素 <strong>带信息排序</strong> 后的结果。</p>
<p>然后对于每一个父亲节点，维护的信息为两个儿子的序列 <strong>每隔 p 个取出一个后形成的序列</strong> 归并排序后的结果，并且对于每一个位置维护其在两个儿子中对应的后继。这里 $p$ 是一个我们自由选取的阈值。</p>
<p>举个例子，假设</p>
<script type="math/tex; mode=display">
p=3, lson=\{1, 2, 5, 6, 7, 9\}, rson=\{3, 6, 7, 12, 15, 18\}</script><p>那么</p>
<script type="math/tex; mode=display">
fa=\{1,3,6,12\}</script><p>其中 $1, 6$ 来自第一个序列， $3, 12$ 来自第二个序列。</p>
<p>这样子的话，我们在区间查询的时候可以对于这一个区间的根节点二分，然后得到两个儿子中的后继，不难发现这里得到的后继与 $x$ 在其儿子中的真实后继差距不超过 $p$ ，这部分暴力即可。由于 $p$ 是常数，复杂度 $O(1)$ 。</p>
<p>然后线段树节点个数为 $O({n\over b})$ ，故一次查询的复杂度变为 $O(\log {n\over b} \log b+{n\over b})$ 。</p>
<p>取 $b=\sqrt{n}$ 得到复杂度 $O(n\sqrt{n})$ 。</p>
<p>最后我们不难发现这个算法可以应对更大的值域，并且做到了强制在线，而且可以利用在线段树上打 tag 的方式实现区间加，这里不多赘述了。</p>
<p>30、<a href="https://www.luogu.com.cn/problem/P5063">P5063 [Ynoi2014] 置身天上之森</a></p>
<p>标签：线段树、分块</p>
<p>一道有手就行的 Ynoi 。</p>
<p>首先我们不难发现对于一次修改，所有 <strong>长度相同</strong> 的线段树节点的修改量 <strong>基本相同</strong> 。</p>
<p>而且对于这个 <strong>区间加区间rank</strong> 的问题，我们一直以来有一个不错的分块解法，即整块二分，最终复杂度 $O(n\sqrt{n\log n})$ 。</p>
<p>然后我们<del>打表</del>不难发现，一棵线段树上长度本质不同的节点最多 $O(\log n)$ 种，而且这些节点的长度是 $2$ 倍 $2$ 倍增长的。</p>
<p>因此我们对于每一种长度的节点分块，然后每一次该怎么做怎么做，最终复杂度是 $T(n)=T(n / 2) + O(n\sqrt{n\log n})$ ，即 $O(n\sqrt{n\log n})$ 。</p>
<p>然后这东西用分散层叠可以优化到 $O(n\sqrt{n})$ ，但没必要。</p>
<p>31、<a href="https://www.luogu.com.cn/problem/P5528">P5528 [Ynoi2012] WC, THUWC, CTSC 与 APIO2017</a></p>
<p>标签：分块，根号分治，定期重构</p>
<p>一道我做了一个下午 + 晚上的大水题，我还是太菜了。</p>
<p>首先这种 <strong>所有模几为几</strong> 的东西大概率根号分治。</p>
<p>一种想法是树分块，但这东西不仅想起来屎还写起来屎， <strong>应该</strong> 被果断弃掉（<del>没错我坚持树分块坚持了一个下午</del>）。</p>
<p>然后我们考虑这样一个事情，我们对于所有 $x &gt; \sqrt{n}$ 的询问可以直接暴跳 <strong>深度</strong> ，但是对于不同的深度我们只取该深度中的一部分修改，我们需要处理这一部分。</p>
<p>一种思路是 dfs 序，但是很不方便，我们考虑 <strong>直接扫</strong> 。</p>
<p>但是复杂度显然会炸，因此我们考虑每 $\sqrt{n}$ 个修改定期重构一次，不难发现这里重构一次是 $O(n)$ 的，并且我们扫整棵树的时候所有存下来的修改都可以直接暴跳啥事儿没有。</p>
<p>然后我们每一次询问额外搜一下最近的几次修改就行了，显然这部分复杂度也是 $O(\sqrt{n})$ 的。</p>
<p>然后是 $&lt; \sqrt{n}$ 的做法，这一部分的一个经典套路就是直接存，因此我们考虑对树分块（注意这里不是一般意义上的树分块），每一个块开一个 $O(\sqrt{n}\times \sqrt{n})=O(n)$ 的数组 $f_{i, j}$ 表示 <strong>深度在模 i 意义下为 j 的点被加了多少</strong> 。</p>
<p>然后我们一次修改显然只会对每一个块进行 $O(1)$ 次修改，然后散块暴力即可。</p>
<p>显然这里直接对 dfs 序分块啥事儿没有，然而 DPair 这个 shabi 胡了一下午树分块。</p>
<p>最终各部分复杂度 $O(n\sqrt{n})$ 空间复杂度也是 $O(n\sqrt{n})$ ，可能略卡常，把重构的 dfs 改成迭代会快很多。</p>
<p>32、<a href="https://www.luogu.com.cn/problem/P5313">P5313 [Ynoi2011] WBLT</a></p>
<p>标签：莫队、bitset、阈值分治</p>
<p>人傻了，这道题不卡常，问题是我写挂了 INF 发（（（</p>
<p>其实是一道不难的题。</p>
<p>首先我们不难发现，我们要求的这个东西有点像把值域分成若干个大小为 $b$ 的块，然后考虑一个最长的块的前缀使得这些块内元素有交。</p>
<p>集合有交不难想到用 <code>bitset</code> 去处理，那么问题转化为把 <code>bitset</code> 分成若干个长度为 $b$ 的段，求一个最长的段的前缀使得这些段与起来不为 $0$ 。</p>
<p>但是我们需要把 <code>bitset</code> 分成若干个长度为 $b$ 的段，这个用传统的 <code>std :: bitset</code> 实现不了，考虑手写，那么用类似分块的方法可以做到每一次询问 $O({V\over w})$ ，其中 $V$ 是值域。</p>
<p>然后这个 <code>bitset</code> 内容的 <strong>维护</strong> 可以用莫队处理。</p>
<p>不过对于 $b \le w$ 的询问， <code>bitset</code> 难以完全发挥优化效果，即我们手写的 <code>bitset</code> 压不了位。比如 $b=1$ 时 <code>bitset</code> 会退化到 $O(V)$ ，因此我们考虑对于这部分另外处理。</p>
<p>不难发现这部分数比较少而且比较小，因此我们考虑分开另外处理。</p>
<p>我们对于每一个 $\le w$ 的 $b$ 跑一次莫队（注意块长要变），然后每一 <strong>组</strong> 询问我们开 $b$ 个 <code>bitset</code> ，令 $t_{i, j}$ 表示模 $b$ 意义下结果为 $i$ 且除以 $b$ 后结果为 $j$ 的数是否存在，然后对于每一个 <code>bitset</code> 求 <code>mex</code> 然后取最大值即可，不难发现这部分的总复杂度仍是 $O({V\over w})$ 。</p>
<p>但是这部分要求动态的 <code>bitset</code> 空间，故照样要手写 <code>bitset</code> 。</p>
<p>最终如果块长合理的话，复杂度应该是 $O(n\sum \sqrt{m_i} + m{V\over w})$ 。</p>

      

    </div>

  </div>
</body>