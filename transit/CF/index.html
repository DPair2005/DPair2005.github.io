 

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="/css/main.css">
  <link rel="stylesheet" type="text/css" href="/css/art.css">
  <link rel="icon" type="images/png" href="/images/favicon.png">
  <script src="/js/element.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.4.0/build/styles/atom-one-light.min.css">
  <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.4.0/build/highlight.min.js"></script>
</head>

<body>
  <script>
    window.onload = function() {
      loadMath();
      drawSaying();
      hljs.configure({ tabReplace: '  ' });
      hljs.initHighlighting()
    }
  </script>

  <div class="content">
    <div class="sidebar" id="sidebar">
      <title>
          Codeforces 做题记录
      </title>
      <script>
    SaveBackground()
  </script>
  <div class="sidebar-title">
    <p style="font-weight: bold; font-size: 25px; font-family: 'ZCOOL XiaoWei';" onclick="drawSaying()"> 
  
  DPairの非自制 blog
      <HR align="center" style="width: 200px;">
    </p>
      <div font="" style="text-align: center; font-size: 18px; font-family: 'ZCOOL XiaoWei';" class="sayingtype" id="sayingtype"> </div>
      <div font="" style="text-align: center; font-size: 6px;"> 　 </div>
    <div class="saying" id="saying"> </div>
  </div>
  <div class="sidebar-body">
  
    <div class="sidebar-content">
      <ul class = "sidebar-menu">
        <a href="/">
          <li class="list-item sidebar-menu-item" id="sidebar-content-home">
            Home
          </li>
        </a>
        <a href="/articles">
          <li class="list-item sidebar-menu-item" id="sidebar-content-articles">
            Articles
          </li>
        </a>
        <a href="/transit">
            <li class="list-item sidebar-menu-item" id="sidebar-content-Transit"
            style="background: #e5e5e5">
            Transit
        </li>
        </a>
        <a href="/tags">
          <li class="list-item sidebar-menu-item" id="sidebar-content-tags">
            Tags
          </li>
        </a>
      </ul>
    </div>
    <div class="sidebar-about">
      <div style="text-align: center; font-size: 16px;"> About DPair </div>
      <HR align="center">
      <div style="margin: 2 auto; width: min-content" onclick="NextBackground()">
        <img class="avatar" alt="DPair" src="/images/avatar.png">
      </div>
      <ul class="sidebar-links">
  
  <li class="sidebar-links-item">
      <a href="https://www.luogu.com.cn/blog/DPair2005/" class="friend-link"> 
        luogu blog 
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://codeforces.com/profile/DPair" class="friend-link"> 
        Codeforces 
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://atcoder.jp/users/DPair" class="friend-link"> 
        AtCoder 
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://gitee.com/DPair" class="friend-link"> 
        gitee 
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://github.com/DPair2005" class="friend-link"> 
        github 
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="mailto:DPair2005@163.com" class="friend-link"> 
        mail 
      </a>
    </li>
  
      </ul>
    </div>
  
    <ul class="sidebar-links">
      <div style="text-align: center; font-size: 16px;"> Friend Links </div>
      <HR align="center">
      
  <li class="sidebar-links-item">
      <a href="https://www.luogu.com.cn/user/140572" class="friend-link"> 
        DSair
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://coderoj.gitee.io/" class="friend-link"> 
        Jacderzhang's blog
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://xyix.gitee.io/" class="friend-link"> 
        xYix's blog
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://www.cnblogs.com/Flying2018/" class="friend-link"> 
        Flying2018's blog
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://www.cnblogs.com/-Wallace-/" class="friend-link"> 
        _Wallace_'s blog
      </a>
    </li>
<li class="sidebar-links-item">
      <a href="https://www.cnblogs.com/Point-King/" class="friend-link"> 
        Point_King's blog
      </a>
    </li>
  
    </ul>
  
  </div>
  
    </div>

    <div class="post" id="post">
      <h1 id="codeforces-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95">Codeforces 做题记录</h1>
<p>感觉 CF 上的题也得写一点题解什么的，写题解总是好的。</p>
<p>这里就彻底乱序了（（ 大家要找某道题题解时建议 <code>ctrl + F</code> （（（</p>
<h4 id="-cf1313d-happy-new-year-https-www-luogu-com-cn-problem-cf1313d"><a href="https://www.luogu.com.cn/problem/CF1313D">CF1313D Happy New Year</a></h4>
<p>你有一个长度为 $m$ 的全 $0$ 的序列，给定 $n$ 个区间，你可以选择其中任意个区间进行区间翻转（即全部异或 $1$ ）的机会，让你使得全局和（即 $1$ 的个数）最大。</p>
<p>保证每一个位置被给出的 $n$ 个区间覆盖的次数不超过 $k$ 次。</p>
<p>$1 \le n \le 10^5, 1 \le m \le 10^9, 1 \le k \le 8$ 。</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>看到这个 $k$ 的奇怪数据范围直接考虑指数级。</p>
<p>由于 $m$ 比较大，我们考虑把每一个区间翻转拆成 $(l, id), (r + 1, -id)$ 两个二元组，然后对所有二元组排序。这部分可能有一些细节，我不多赘述了，留给读者自行思考。</p>
<p>设 $dp[i][S]$ 表示选到第 $i$ 个二元组且这个点上被选了的集合为 $S$ 的最大权值。</p>
<p>考虑其转移，当这个点的二元组是某一个修改的开始点时，考虑当前新加入的修改是否选由自己决定，其他的与上一个位置必须一一对应。</p>
<p>删除一个修改同理，故转移是 $O(|S|)=O(2^k)$ 的。</p>
<p>最终复杂度 $O(n2^k)$ ，可以通过本题。</p>
</details>

<hr>
<h4 id="-cf891c-envy-https-www-luogu-com-cn-problem-cf891c"><a href="https://www.luogu.com.cn/problem/CF891C">CF891C Envy</a></h4>
<p>给你一幅有边权的连通无向图，　$q$ 次询问，每次问你一个边集中的所有边是否可能同时出现于某棵最小生成树中。</p>
<p>所有数　$\le 5\times 10^5$ 。</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>首先最小生成树有两个性质：</p>
<p>其一就是对于一幅图，其最小生成树中某种边权的边的数量是固定的。</p>
<p>其二就是加入所有小于等于某一权值的所有边后形成的连通块是固定的。</p>
<p>这启示我们分权值考虑。</p>
<p>这个东西可以用 LCT 或者可持久化并查集什么的处理，但是还有更好的做法。</p>
<p>我们考虑先克鲁斯卡尔一遍，然后对于每一种权值，我们先存下来这种权值中每一条边当前所连接的两个连通块的编号，然后再把这些边加入边集。</p>
<p>那么询问时每一组权值用并查集判一下是否出现环即可，若出现则无解，反之有解。</p>
<p>最终复杂度 $O(n\log n)$ （假装它同阶），可以通过本题。</p>
</details>

<hr>
<h4 id="-cf886e-maximum-element-https-www-luogu-com-cn-problem-cf886e"><a href="https://www.luogu.com.cn/problem/CF886E">CF886E Maximum Element</a></h4>
<p>有一个求序列最大值的 <strong>假算法</strong> 的逻辑为当一个数大于其后面的 $k$ 个数，就返回这个值。问你有多少个 $1 - n$ 的排列满足序列会返回错误的答案。</p>
<p><del>感觉我概括的不是很好建议去看原题面。</del></p>
<p>$n, k \le 10^6$</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>注意到返回值错误不仅需要中途退出，返回值还不能是 $n$ 。</p>
<p>我们考虑 dp，设 $f_i$ 表示 $1-i$ 的排列没有<strong> 中途退出 </strong>的排列数。</p>
<p>考虑枚举新加入的 $i$ 的位置，这个值的位置显然只能出现在 $[i-k+1, i]$ 之中。</p>
<p>化一下之后发现是一个前缀和优化的形式，这部分复杂度 $O(n)$ ，其中涉及到预处理逆元也可以做到 $O(n)$ 。</p>
<p>然后就是求退出 $n$ 的方案数，考虑枚举 $n$ 的位置，并且 $n$ 前面没有中途退出的就行了，这个简单枚举即可。</p>
<p>最终复杂度 $O(n)$</p>
</details>

<hr>
<h4 id="-cf460d-little-victor-and-set-https-www-luogu-com-cn-problem-cf460d"><a href="https://www.luogu.com.cn/problem/CF460D">CF460D Little Victor and Set</a></h4>
<p>给你 $l, r, k$ ，让你在 $[l, r]$ 中选至多 $k$ 个互不相同的数使得这些数异或和最小，不能不选。</p>
<p>$1\le l \le r \le 10^{12}, 1 \le k \le 10^6$ 。 </p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>首先不难发现对于任意的 $n=2k$ ，$n, n+1, n+2, n+3$ 的异或和一定是 $0$ ，$n, n + 1$ 的异或和一定是 $1$ 。</p>
<p>于是我们首先考虑枚举小范围的答案（即 $[l, r]$ 长度较小），那么剩下的情况区间都比较大，可以套用刚才的结论。</p>
<p>那么 $k \ge 4$ 的情况答案为 $0$ ，$k=2$ 时简单分类讨论即可， $k=1$ 时答案显然为 $l$ 。</p>
<p>最后考虑 $k=3$ ，不难发现此时 $1$ 的答案必定存在，考虑是否可能出现 $0$ 。</p>
<p>我们设答案的三元组升序排序后为 $(a, b, c)$ ，我们考虑枚举 $c$ ，那么就是要使得 $b$ 与 $c$ 的异或值 $a$ 尽可能大，同时 $c$ 尽可能小，然后均出现在 $[l, r]$ 之中。</p>
<p>不难发现最优的情况一定是 $c=2^{x} + 2^{y}$ 的形式，然后 $b=c-1$ 。</p>
<p>那么枚举即可。</p>
</details>

<hr>
<h4 id="-cf1117g-recursive-queries-https-www-luogu-com-cn-problem-cf1117g"><a href="https://www.luogu.com.cn/problem/CF1117G">CF1117G Recursive Queries</a></h4>
<p>给你一个排列， $q$ 次强制离线的询问，每一次询问一段区间 $[l, r]$ 形成的笛卡尔树上每一棵子树大小的和。</p>
<p>数据范围 $10^6$ 级别。</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>我们先用一个单调栈处理出每一个点向左和向右第一个比它大的位置，分别记作 $L_i, R_i$ 。</p>
<p>那么每一次询问要求的就是 $\sum_{i=l}^r \min(R_i, r) - \max(L_i, l)$ ，不难发现前后两部分无关，可以拆开来做。</p>
<p>那么离线下来扫一遍即可，每一次两个树状数组实现单点修改区间查询即可。</p>
<p>最终复杂度 $O(n \log n)$ 。</p>
</details>

<hr>
<h4 id="-cf526g-cf526g-spiders-evil-plan-https-www-luogu-com-cn-problem-cf526g"><a href="https://www.luogu.com.cn/problem/CF526G">CF526G CF526G Spiders Evil Plan</a></h4>
<p>给你一棵有边权的树， $q$ 次询问，每次给定一个二元组 $(x, y)$ ，问你在树上选出 $y$ 条路径，要求这 $y$ 条路径组成的连通块中的边权和最大且 $x$ 属于这个连通块，输出这个最大值，强制在线。</p>
<p>所有数 $\in [1, 10^5]$ 并保证不爆 <code>int</code> 。</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>首先我们注意到 $k$ 条路径一定可以覆盖一棵有 $2k$ 个叶子节点的树，证明略，可以感性理解或当做结论背下来。</p>
<p>然后我们不难发现答案一定带一个直径的端点，故以两个直径的端点为根分别处理问题，然后每次询问取一个 $\max$ 即可，由于这个点一定是一个叶子，问题就转化为了选 $2k-1$ 个叶子然后使得这些叶子到根的路径的并集所组成的连通块中边权和最大，并且要包含 $x$ 。</p>
<p>我们考虑对这棵树进行有边权的长链剖分，不难发现我们选择的一定是最长的前 $2k-1$ 条链，而这些链是不交的。</p>
<p>但是这样不一定包含 $x$ ，那么我们此时有两种选择，一种是把 $x$ 直接并到连通块当中然后删掉当前连通块中最短的链，另一种是直接把 $x$ 往上倍增后跳到的链一直到叶子都删掉，然后改接 $x$ ，显然最优解一定出现在这两种情况之一中。</p>
<p>那么直接分讨一下然后按上面所说的处理即可，复杂度为倍增和排序的 $O(n\log n)$ 。</p>
</details>

<hr>
<h4 id="-cf1062f-upgrading-cities-https-www-luogu-com-cn-problem-cf1062f"><a href="https://www.luogu.com.cn/problem/CF1062F">CF1062F Upgrading Cities</a></h4>
<p>给你一幅 DAG ，问你有多少个点 $x$ 满足至多有一个点 $y$ 满足 $y$ 不能被 $x$ 到达且 $x$ 不能被 $y$ 到达。</p>
<p>$|V|, |E| \le 3\times 10^5$</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>不难发现，我们要求的应该是每一个点能到达的点数。</p>
<p>考虑建正反图然后拓扑排序。</p>
<p>不难发现，若一个时刻队列中点数 $\ge 3$ ，那么这些点显然互不到达，故全部无解不需要考虑，我们只需要讨论队列中点数 $< 3$ 的情况。</p>
<p>首先若队列中只有一个点，显然剩下所有没被访问到的点都要经过这个点。</p>
<p>然后若队列中有 $2$ 个点，考虑另一个点是否可以到达一个度为 $1$ 的点，若可以，则说明当前点除了另一个点以外还有不能到达的点，故直接无解，否则统计贡献。</p>
<p>然后根据一个点能到达和能被到达的点数判断是否成立即可，一种实现技巧是不合法的情况不统计贡献，那么显然这些不合法的点一定在贡献上亦不合法。</p>
<p>复杂度 $O(n)$ 。</p>
</details>

<hr>
<h4 id="-cf1311e-construct-the-binary-tree-https-www-luogu-com-cn-problem-cf1311e"><a href="https://www.luogu.com.cn/problem/CF1311E">CF1311E Construct the Binary Tree</a></h4>
<p>让你构造一棵 $n$ 个节点深度和为 $d$ 的二叉树，并判断有没有解。</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>首先有无解很好判，显然最小值为完全二叉树的情况，这个堆式建树即可。</p>
<p>判完之后考虑从最后一个点开始换父亲，考虑记录最后一个没有儿子的节点，若能连（即深度符合条件）则连到这个节点上。</p>
<p>显然每一层要至少留一个节点，考虑留 $2^k$ 的节点。</p>
<p>那么此时所有节点必然满足最多只有一个儿子。</p>
<p>考虑最后一个节点换父亲时深度不满足题意了，由于其祖先深度连续且最多只有一个儿子，故暴力往上跳直到深度符合条件为止。</p>
<p>正确性显然，复杂度 $O(n)$ 。</p>
</details>

<hr>
<h4 id="-cf446c-dzy-loves-fibonacci-numbers-https-www-luogu-com-cn-problem-cf446c"><a href="https://www.luogu.com.cn/problem/CF446C">CF446C DZY Loves Fibonacci Numbers</a></h4>
<p>区间加斐波那契数列区间和。</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>这道题就我所知有至少两种做法。</p>
<p>首先加斐波那契数列的操作如果用暴力去做的话，仔细想想不难发现是可以合并的，故可以根号次定期重构，复杂度 $O(n\sqrt{n})$ ，这个做法比较显然就不展开讲了。（但是实战的时候反而这个做法可能更好用）。</p>
<p>我们考虑斐波那契数列不好维护的原因在于难以合并标记（这里与上面暴力合并斐波那契数列是不同的），因此我们需要改变维护的信息使得其可以被方便地合并。</p>
<p>考虑能不能将其转化成区间加或者其他类似的东西。</p>
<p>利用斐波那契数列的一个性质： $f_{i+j}=f_{i+1}f_j+f_if_{j-1}$ 。</p> 
<p>我们考虑把与 $i$ 有关的提取出来，不难发现问题变成了两个标记的区间加，这个就很好处理了。</p>
<p>另外这里出现了负下标的斐波那契数，考虑从后往前逆推，不难发现仍满足上面那个式子。</p>
<p>由此解决了这个问题，复杂度 $O(n\log n)$ 。</p>
<p>当然你也可以直接上斐波那契数列的通项公式，不过这个东西怎么维护我就不知道了。</p>
<p>据说这道题还有矩阵乘法的做法？</p>
</details>

<hr>
<h4 id="-cf506d-mr-kitayuta-s-colorful-graph-https-www-luogu-com-cn-problem-cf506d"><a href="https://www.luogu.com.cn/problem/CF506D">CF506D Mr. Kitayuta&#39;s Colorful Graph</a></h4>
<p>给你一幅边有颜色的无向图，我们称一个包含所有某种颜色为 $c$ 的边的子图，每次询问两个点在多少种颜色的子图上连通。</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>这道题就我所知也有至少两种做法。</p>
<p>一方面你可以根号分治，对于出现次数 $> \sqrt{n}$ 的颜色暴力并查集，剩下的暴力 $O(n^2)$ 统计贡献，不难发现这样子的复杂度前半部分显然是 $O(n\sqrt{n} \alpha(n))$ ，后半部分每个点最多碰到 $\sqrt{n}$ 个点，故复杂度 $O(n\sqrt{n})$ ，然后存贡献可能要用到 map 什么的故多一只 $\log$ 。</p>
<p>但是这样比较难写，看了题解之后发现有更好的实现方式。</p>
<p>考虑对于每一个点统计其出度，然后我们称一个点的颜色集合为所有与它联通的边的颜色构成的集合，对于每一种颜色，我们对其包含的所有点开并查集，不难发现这样总点数是 $O(m)$ 的。</p>
<p>考虑查询的时候扫描颜色集合更小的那个点的颜色集合的并查集。</p> 
<p>显然若这个集合大小 $< \sqrt{m}$ 则复杂度显然正确，考虑度数为 $x$ 的点，它只能与度数 $> x$ 的点产生贡献，我们不妨把取 $\min$ 改成加起来，然后不难发现每一个点贡献之和是 $O(m)$ 的，然后点数又是 $\sqrt{m}$ 级别，股复杂度正确。</p>
<p>最后多一只可以忽略不计的 $\alpha$ 。</p>
</details>

<hr>
<h4 id="-cf521d-shop-https-www-luogu-com-cn-problem-cf521d"><a href="https://www.luogu.com.cn/problem/CF521D">CF521D Shop</a></h4>
<p>给你 $k$ 个正整数和 $n$ 种操作，每次操作形如给一个数赋值或给一个数加上一个数或给一个数乘上一个数，问你最多进行 $m$ 次操作（每个操作最多一次）后能得到的序列最大乘积所需要选的操作。</p>
<p>数据范围 $10^5$ 。</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>首先考虑赋值一定在加法前面</p>
<p>加法一定在乘法前面</p>
<p>乘法的效果可以 $O(1)$ 求出，因为求的是序列之积</p>
<p>那么现在需要考虑的就是赋值和加法。</p>
<p>首先一个点不会被赋值多次，所以赋值显然可以转化为最大的那个加法</p>
<p>由于加法不讲次序，故把赋值转成加法后，仍可以认为先进行所有赋值再进行所有加法，哪怕事实不是这样，所以现在只需要考虑加法的影响。</p>
<p>显然同一个数的加法一定从大往小选，故可以转化为乘法。</p>
<p>然后直接排个序就好了。</p>
</details>

<hr>
<h4 id="-cf1225f-tree-factory-https-www-luogu-com-cn-problem-cf1225f"><a href="https://www.luogu.com.cn/problem/CF1225F">CF1225F Tree Factory</a></h4>
<p>给你一棵树，你要构造一条有根链，你可以对这条链进行若干次形如 $fa_i \gets fa_{fa_i}$ 的操作，你构造出来的链需要满足进行最小次数的操作可以使得这条链变为原树，输出链的形态和操作序列。</p>
<p>$n \le 10^5$ 并保证答案的操作次数 $\le 10^6$</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>基本胡出来了，但是关键步骤想岔了（（</p>
<p>首先不难发现我们可以逆推，即把原树转成链，那么每一步操作就是把一个兄弟变成父亲。</p>
<p>那么类比成合并，因此我们要求的就是最小合并次数。</p>
<p>我们称 $fa_x \gets y$ 的过程为 “把子树 $x$ 合并到子树 $y$ 上” ，不难发现一次合并的代价是 $y$ 子树内的最大深度。</p>
<p>因此我们从根开始遍历，每一次把当前点的所有儿子合并只留下一个儿子，不难发现这样子的话被合并的所有层都只有一个节点，故当前点的所有儿子就是下一层的所有节点。</p>
<p>考虑对所有儿子按最大深度排序（看了题解好像直接长剖也可以），然后每次把最大的合并到次大的，最后只留下一个儿子。</p>
<p>然后顺着每一个点剩下的这个儿子遍历整条链就可以得到链的结构，把所有合并操作逆序就是链变成树所需要的操作。</p>
<p>复杂度 $O(k \log n + n)$ ，这里 $k$ 是答案 ，用 $dfs$ 序似乎可以做到 $O(k+n)$ 。</p>
</details>

<hr>
<h4 id="-cf1179d-fedor-runs-for-president-https-www-luogu-com-cn-problem-cf1179d"><a href="https://www.luogu.com.cn/problem/CF1179D">CF1179D Fedor Runs for President</a></h4>
<p>给你一棵树，你要加一条边（可以重边甚至自环），使得树上的无向简单路径最多，这里无向简单路径定义为每一个点至多经过一次的路径。</p>
<p>$n \le 5\times 10^5$</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>首先我们得知道这个答案怎么算。</p>
<p>不难发现我们只需要新增的无向简单路径最多即可，不难发现<strong> 新增的无向简单路径=全部可能的新增无向简单路径-不可能新增的无向简单路径 </strong>。</p>
<p>考虑前面这个东西等于 ${1\over 2}n(n-1)$ ，那么我们考虑后面这个东西是什么。</p>
<p>假设我们选择的两个点是 $(u, v)$ ，显然 $(u, v)$ 在原树上可以拉出来一条链，然后我们惊奇的发现，剩下来的点中任选两个点，若这两个点在原树上的路径与我们拉出来的链有交，那么我们新增的这条边就可以被这对点经过。</p>
<p>那么我们考虑怎样子的两个点与原链是没有交的。我们发现，以链上的每一个点为根，然后往所有不在链上的点扩展之后形成的子树中，任意两点与原链无交，并且剩下的任意两点都与原链有交。</p>
<p>设这些子树大小为 $s$ ，于是答案为 ${1\over 2}(n(n-1)-\sum s_i(s_i-1))$ 。</p>
<p>那么我们现在要做的就是最小化后面那个东西。</p>
<p>首先，考虑我们选择的两个点必然是两个叶子，原因在于 $(a+b)^2 > a^2 + b^2 (a, b > 0)$ ，所以我们对于一条选中的链，我们把两端往叶子扩展可以使得边缘两棵子树被拆分成更小的子树，故显然更优。</p>
<p>于是我们发现这东西像极了直径。</p>
<p>考虑以 $1$ 为根开始 dfs 搜到的最优点是 $x$ ，我们需要证明这个 $x$ 一定在最终答案上。</p>
<p>考虑假设另一个点 $y$ ，那么对于 $(1, x)$， $(1, y)$ 来说，前者更优，而且我们也不难发现我们现在要证明的东西变成了对于任意第三点 $z$ ，$(y, z)$ 不可能是最优的。</p>
<p>不妨设以 $1$ 为根时， $x, y$ 的 LCA 为 $k$ ，那么我们不难发现 $(k, x)$ 优于 $(k, y)$ ，然后我们分类讨论 $z$ 。</p>
<p>假设 $z$ 在 $k$ 子树外，不难发现问题转化为 $(k, x) + (z, k)$ 与 $(k, y) + (z, k)$ 比大小，显然前者更优。</p>
<p>假设 $z$ 在 $k$ 子树内，考虑继续分讨，假设 $(y, z)$ 的 LCA 也是 $k$ ，那么显然 $(x, k) + (k + y)$ 优于 $(z, k) + (k, y)$ 。</p>
<p>假设 LCA 不为 $k$ ，那么不难发现此时 $(x, y)$ 比 $(y, z)$ 更优。</p>
<p>故用类似直径的方法处理即可，复杂度 $O(n)$ 。</p>
</details>

<hr>
<h4 id="-cf611h-new-year-and-forgotten-tree-https-www-luogu-com-cn-problem-cf611h"><a href="https://www.luogu.com.cn/problem/CF611H">CF611H New Year and Forgotten Tree</a></h4>
<p>给你一棵树，但是每一条边的两个端点，我们只知道它在十进制下的位数，让你构造一棵合法的树，或判断无解。</p>
<p>$n \le 2\times 10^5$</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>大神仙题。</p>
<p>首先我们不难发现，合法的 “位数” 最多 $\log_{10}$ 种，大概就是 $6$ 的样子，非常小。</p>
<p>然后我们可以把这棵树的结构看成儿子与父亲的一个匹配。</p>
<p>于是我们可以根据 Hall 定理来判断是否有解。</p>
<p>然后考虑怎么输出方案，我们先考虑暴力怎么做。</p>
<p>我们设每一种位数为一个 “颜色” ，那么显然这棵树可以看做颜色内部连边，颜色之间连边。</p>
<p>我们考虑把所有连通的点缩成一个点，那么每一次暴力判断两个颜色之间的连边，其实可以看做从颜色 $u$ 的在连通块内的点向颜色 $v$ 中不在连通块内的一个点连边。</p>
<p>但是这样可能会出现不合法的情况，不难发现暴力判断复杂度是很小的，因此每一条边暴力判断是否合法即可，这样是能过的。</p>
</details>

<hr>
<h4 id="-cf1209f-koala-and-notebook-https-www-luogu-com-cn-problem-cf1209f"><a href="https://www.luogu.com.cn/problem/CF1209F">CF1209F Koala and Notebook</a></h4>
<p>给你一幅无向连通图，定义一条路径的权值为从起点开始经过的所有边的编号 <strong>顺次相连</strong> 形成的十进制数的大小，问你从 $1$ 号点开始到所有点的最短路。</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>首先考虑拆边（其实这东西挺直观的但是我没想到），每一条边拆成若干在十进制下只有一位的边，那么这样子经过一条边就一定是 “乘 10 加 x” 的格式了。</p>
<p>然后我们不难发现，这样的话经过的边越少越好。一个直观的想法就是 bfs ，因为 bfs 能够保证每一次扩展到的点里源点的距离最小。</p>
<p>考虑用类似 Prim 的做法，我们处理出一个被 bfs 到的连通块。</p>
<p>可以理解成被 bfs 到的所有深度相同的点一起处理。</p>
<p>然后把所有连出去的边按边权排序，然后扩展即可。</p>
<p>显然这么一层一层扩展是对的。</p>
<p>另外，如果一个点一个点扩展可能无法得到最优解。</p>
<p>最终复杂度应该是 $O(n\log n)$ ，而且这个 $\log$ 似乎是拆点的 $\log$ 。</p>
</details>

<hr>
<h4 id="-cf914f-substrings-in-a-string-https-www-luogu-com-cn-problem-cf914f"><a href="https://www.luogu.com.cn/problem/CF914F">CF914F Substrings in a String</a></h4>
<p>给你一个字符串，支持单点修改区间询问某个串的出现次数。</p>
<p>保证所有询问串长度之和不超过 $10^5$ ，其他数据范围也都是 $10^5$</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>首先有一个 $O(n\sqrt{n})$ 的做法。</p>
<p>我们传统艺能对询问串根号分治，然后 $> \sqrt{n}$ 的暴力建 SAM 匹配。</p>
<p>$<\sqrt{n}$ 的部分对序列分块，不难发现一个串最多跨两个块，那么把块间和块内分别建 SAM 即可。</p>
<p>那么修改的时候重构 SAM ，这样修改查询都是 $O(\sqrt{n})$ 的，但是这个做法显然常数极大。</p>
<p>考虑用其他方式来进行字符串匹配，比如 bitset 。</p>
<p>我们先用一个 bitset 维护所有可行位置，初始为全 $1$ ，然后对于字符集中的每一个字符建 bitset ，通过按位与可以方便的求出所有可行的位置。</p>
<p>然后用差分或者手写 bitset 的方法求 bitset 上的区间和即可。</p>
<p>复杂度 $O({nq\over w})$ 。</p>
</details>

<hr>
<h4 id="-cf587f-duff-is-mad-https-www-luogu-com-cn-problem-cf587f"><a href="https://www.luogu.com.cn/problem/CF587F">CF587F Duff is Mad</a></h4>
<p>给你 $n$ 个串 $s_i$ ，$q$ 次询问，每次问你 $\sum_{i=l}^r occur(s_i, s_k)$ ，其中 $l, r, k$ 是给定的常数， $occur(s, t)$ 表示 $s$ 在 $t$ 中的出现次数。</p>
<p>$1 \le n, \sum|s_i|, q \le 10^5$ 。</p>
<hr>
<details>
<summary><strong> 具体解法 </strong></summary>
<p></p>
<p>被另一道题影响了导致走了很远的弯路，看完题解才发现这道题其实是挺简单的。</p>
<p>首先这道题就是一个多组询问的多模匹配。</p>
<p>考虑文本串数量十分有限，我们考虑处理文本串。</p>
<p>然后对于这种 “总和 $\le$ 某数” 的数据，可以考虑根号分治。</p>
<p>考虑对于 $|s_i| > \sqrt{n}$ 的串，这种串最多 $\sqrt{n}$ 个，因此考虑对于每一个这样的串建 SAM 。然后对于每一个这种串暴力重构，求出所有串在这个串中的出现次数，然后询问就可以 $O(1)$ 前缀和查询，这部分复杂度是 $O(n\sqrt{n})$ 的。</p>
<p>考虑 $|s_i| \le \sqrt{n}$ 的，我们可以 $O(\sum \sqrt{|s_i|}^2)$ 枚举出一个串的所有子串的哈希值，</p>
<p>然后顺着每一个点剩下的这个儿子遍历整条链就可以得到链的结构，把所有合并操作逆序就是链变成树所需要的操作。</p>
<p>复杂度 $O(k \log n + n)$ ，这里 $k$ 是答案 ，用 $dfs$ 序似乎可以做到 $O(k+n)$ 。</p>
</details>

<hr>

      

    </div>

  </div>
</body>