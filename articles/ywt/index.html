<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="stylesheet" type="text/css" href="/css/art.css">
    <link rel="icon" type="images/png" href="/images/favicon.png">
    <script src="/js/header.js"></script>
<script src="/js/search.js"></script>
<script src="/js/theme.js"></script>
<script src="/js/hitokoto.js"></script>

    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/styles/atom-one-light.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/highlight.min.js"></script>
    <script src="/js/language.min.js"></script>
    <title>
        压位 Trie 学习笔记 - DPairの非自制 blog
    </title>
</head>

<body>
        <script src="//cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="/js/load_theme.js"></script>

    <script>
        window.onload = function() {
            loadMath();
            drawSaying();
            hljs.configure({ tabReplace: '    ' });
            hljs.highlightAll()
        }
    </script>

    <div class="content">
        <div class="sidebar" id="sidebar">
            <script>
    document.heartland = false;
    window.localStorage.setItem('heartland', false);
</script>

<div class="sidebar-title">
    <p style="font-weight: bold; font-size: 25px; font-family: 'ZCOOL XiaoWei';" onclick="drawSaying()"> 
    DPairの非自制 blog
    </p>
    <hr align="center" style="width: 200px;">
    <p></p>
    <div font style="text-align: center; font-size: 18px; font-family: 'ZCOOL XiaoWei';" class="sayingtype" id="sayingtype"> </div>
    <div font="" style="text-align: center; font-size: 6px;"> 　 </div>
    <div class="saying" id="saying"> </div>
</div>


<div class="sidebar-body">

    <div class="sidebar-content">
        <ul class="sidebar-menu">
            <a href="/">
                <li class="list-item sidebar-menu-item" id="sidebar-content-home">
                    Home
                </li>
            </a>
            <a href="/articles">
                <li class="list-item sidebar-menu-item" id="sidebar-content-articles" style="background: #e5e5e5">
                    Articles
                </li>
            </a>
            <a href="/tags">
                <li class="list-item sidebar-menu-item" id="sidebar-content-tags">
                    Tags
                </li>
            </a>
        </ul>
    </div>

    <div class="sidebar-about">
    <div style="text-align: center; font-size: 16px;">
        <a href="/aboutme" style="text-decoration: none; color: currentColor;">
            About me
        </a>
    </div>
    <HR align="center">
    <div class="avatar-rotate" style="margin: 2 auto; width: min-content">
        <img class="avatar" alt="DPair" src="/images/avatar.png", onclick="NextBackground()"></img>
    </div>

    <ul class="sidebar-links">
    <li class="sidebar-links-item">
        <a href="https://dpair2005.github.io" class="friend-link">
            github blog 
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://dpair.gitee.io" class="friend-link">
            gitee blog 
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://www.luogu.com.cn/blog/DPair2005/" class="friend-link">
            luogu blog 
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://codeforces.com/profile/DPair" class="friend-link">
            Codeforces 
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://atcoder.jp/users/DPair" class="friend-link">
            AtCoder 
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://github.com/DPair2005" class="friend-link">
            github 
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://gitee.com/DPair" class="friend-link">
            gitee 
        </a>
    </li>
    </ul>

</div>

<ul class="sidebar-links">
    <div style="text-align: center; font-size: 16px;"> links </div>
    <HR align="center">

    <li class="sidebar-links-item">
        <a href="https://coderoj.gitee.io/" class="friend-link">
            Jacder's blog
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://xyix.github.io/" class="friend-link">
            xYix's blog
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://www.cnblogs.com/flying2018" class="friend-link">
            flying2018's blog
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://www.cnblogs.com/Point-King/" class="friend-link">
            Point_King's blog
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://cnblogs.com/pealfrog" class="friend-link">
            xtw's blog
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="http://xyf007.ml/" class="friend-link">
            xyf007's blog
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://www.cnblogs.com/zkdxl" class="friend-link">
            zkdxl's blog
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://www.cnblogs.com/guts" class="friend-link">
            krimson's blog
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://blog.moonpie.cf/" class="friend-link">
            moonpie's blog
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://www.luogu.com.cn/blog/wh2005blog/" class="friend-link">
            wuhao2005's blog
        </a>
    </li>
<li class="sidebar-links-item">
        <a href="https://blog.jasonfan.ml/" class="friend-link">
            jasonfan's blog
        </a>
    </li>

</ul>



</div>
        </div>

        <div class="post" id="post">
            <h1>压位 Trie 学习笔记</h1>
            <h2 id="0-%E5%89%8D%E8%A8%80">0 前言</h2>
<p><strong>本文学习自 @skip2004 的集训队论文 《浅谈亚 log 数据结构在 OI 中的应用》。本文将按论文顺序介绍笔者的个人理解和思考。</strong></p>
<p>由于本人更侧重于 OI 中的 <strong>广泛应用</strong>，所以只考虑 <strong>简单实现</strong> ，过于毒瘤或卡常的实现不 <strong>作</strong>（感谢@Jacderzhang）考虑。</p>
<h2 id="1-dynamic-predecessor-problem">1 Dynamic Predecessor Problem</h2>
<p>论文的这一部分主要介绍了 <strong>Dynamic Predecessor Problem</strong> 是一个怎样的东西，实际上就是 <strong>加点删点然后求前驱后继</strong> 。论文里另外讲了几种常见的解法，都比较简单在此不赘述。</p>
<p><a href="https://www.luogu.com.cn/problem/U156719">测试连接</a></p>
<h2 id="2-%E5%8E%8B%E4%BD%8D-trie">2 压位 trie</h2>
<h3 id="2-0-%E5%89%8D%E8%A8%80">2-0 前言</h3>
<p><del>Jacderzhang：“这东西不是很简单吗？去年冬令营wys都讲过。”</del></p>
<p><del>DPair：“去年冬令营啊，我只记得‘CCF实行三M原则’了……”</del></p>
<h3 id="2-1-%E7%AE%80%E4%BB%8B">2-1 简介</h3>
<p>压位 Trie，顾名思义，就是压位的 Trie 树，对于这道题我们显然要对值域开 Trie。</p>
<p>我们发现一般用来处理问题的 Trie 树都是按当前位的 $0/1$ 来分类的，最终一次的复杂度是 $O(\log_2 V)$ 的。</p>
<p>这不太行，我们考虑用压位的思想处理这个问题。</p>
<p>那既然你一个结点两个儿子不够，那么我开 $w$ 个儿子，树的深度就降低了，就可以在 $O(\log_w V)$ 的时间内处理问题了。</p>
<p>借用一张论文里面的图，应该可以帮助理解。</p>
<p><img src="./pic1.png" alt=""></p>
<p>上图事实上维护了一个值域为 $[0, 2^4)$ 的问题，取 $w=4$ ，所以总层数为 $\log_42^4=2$ 。每一个结点维护的是自己的子树中 <strong>有哪几个有值</strong> 。例如图中维护的数字集合就是 ${0, 2, 9, 10, 11, 12, 13, 14, 15}$ ，所有有数的点为深色。</p>
<p>至于为什么 ￥gg 的论文里面 root 没有标深色，<del>我也不知道</del>，但按我个人的理解是要标的。可能是没必要标（毕竟你这个数集里面有没有元素全局维护即可）。</p>
<p>并且，这里我们也可以初步看出，对于一个压位 Trie ，我们一方面不能动态开点（不然要记录儿子）。</p>
<h3 id="2-2-%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86">2-2 操作处理</h3>
<p>回归正题，不难发现我们可以把这棵树看做一棵 leafytree ，当然也可以理解成线段树。这对我们处理修改和询问有一定的帮助。</p>
<p><strong>注：接下来我们认为值域是 $2^k$ 即卡满，至于为什么这么写。。。这是因为 DPair 写挂了一个地方然后不想改了（（</strong></p>
<h4 id="2-2-1-%E6%8F%92%E5%85%A5">2-2-1 插入</h4>
<p>首先我们考虑插入操作，不难发现我们和普通 Trie 的插入方式一致是可以做到的。考虑从根结点开始，往我们插入的方向一直走，沿途打标记即可。复杂度 $O(\log_w 2^k)$ 。</p>
<h4 id="2-2-2-%E5%88%A0%E9%99%A4">2-2-2 删除</h4>
<p>与插入同理，最后把空的子树标记清除一下即可，同样也是沿途修改。复杂度 $O(\log_w 2^k)$ 。</p>
<h4 id="2-2-3-%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7">2-2-3 前驱后继</h4>
<p>这两个没有本质区别，故并举，下面只讨论前驱。</p>
<p>首先我们显然要从根开始往下搜，那么对于在一可子树内找 $x$ 的前驱，我们分两类处理：</p>
<ol>
<li>这一位就已经 $&lt; x$ ，那么直接在左边最大的子树中查找最大值即可，显然最优。复杂度 $O(\log_w 2^k)$。</li>
<li>这一位 $=x$ ，这一部分需要考虑 $x$ 在自己所对应的子树内有没有前驱，如果有的话显然更优。</li>
</ol>
<p>所以我们先搜索 $2$ 情况，不合法再搜 $1$ 情况。</p>
<p>咋看之下这东西是 $O(\log_w^22^k)$ 的。</p>
<p>事实上，不难发现我们可以 $O(1)$ 判断 $1$ 情况是否有解，故 $1$ 情况最多被执行一次，最终复杂度还是 $O(\log_w2^k)$ 的。</p>
<p>用 <code>unsigned long long</code> 压位可以压到 $w=64$ 。</p>
<h3 id="2-3-%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">2-3 关于空间复杂度</h3>
<p>假设树的大小为 $2^k$ 。由于不能动态开点，朴素实现的话空间和线段树类似是 $O(2^k)$ ，但这对于<del>像我一样的</del>毒瘤出题人们来说过于 naive。不过其实也不难发现这东西的空间优化方式和线段树类似，压位 Trie 的最后一层有 $2^k$ 个结点，但本质上什么都没有记录，所以可以直接优化掉，最终为 $O({2^k\over w})$ 。</p>
<h3 id="2-4-%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96">2-4 一些优化</h3>
<p>￥gg 论文里面说这部分是压位 Trie 的实现，单个人觉得像是在写优化，所以直接当优化去理解了。</p>
<p>首先我们采取分层维护的方式，每一层开一个对应大小的数组来进行维护，可以尽可能压缩空间。</p>
<h4 id="2-4-1-%E6%8F%92%E5%85%A5">2-4-1 插入</h4>
<p>然后不难发现，每一个值在每一层对应的位置都可以非常方便地求出，故插入时考虑自下而上遍历。如果已经插入过的话就可以直接弹出，达到剪枝的效果。</p>
<h4 id="2-4-2-%E5%88%A0%E9%99%A4">2-4-2 删除</h4>
<p>删除同理，如果某一个结点删完之后还有数，那么就可以不继续向上走而直接跳出了。</p>
<p>而且不难发现如果自上而下的话，删除需要上下行两趟操作，现在只需要一趟。</p>
<h4 id="2-4-3-%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7">2-4-3 前驱后继</h4>
<p>我们还是只讨论前驱。</p>
<p>不难发现，我们自下而上的话，就是从当前的 $x$ 开始，如果其左侧存在结点，那么就可以直接对应找最大值了，也减少了常数。</p>
<p>这些剪枝已经足够了，而且实现上并不困难。</p>
<h3 id="2-5-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2-5 代码实现</h3>
<p>基本完全搬的 @skip2004 的，因为实现的真的太好了我感觉改哪里都亏（（</p>
<p>实现了 <a href="https://www.luogu.com.cn/problem/U156719">这道题</a>。</p>
<details>
<summary> 点此展开代码 </summary>
  <pre><code class="lang-cpp">#include &lt;cstdio&gt;

namespace BITWISE{
    inline int clz(unsigned long long x){return __builtin_clzll(x);}//这个函数是查询开头几个零
    inline int ctz(unsigned long long x){return __builtin_ctzll(x);}//这个函数是查询末尾几个零
} // namespace BITWISE
using namespace BITWISE;
namespace GenHelper{
    unsigned z3, z4, b;
    inline unsigned rand_(){
        z3 = ((z3 &amp; 4294967280U) &lt;&lt; 7) ^ ((z3 &lt;&lt; 13) ^ z3) &gt;&gt; 21;
        z4 = ((z4 &amp; 4294967168U) &lt;&lt; 13) ^ ((z4 &lt;&lt; 3) ^ z4) &gt;&gt; 12;
        return (z3 ^ z4);
    }
}
inline void srand_(unsigned x){
    using namespace GenHelper;
    z3 = x ^ 0x1234598766U;
    z4 = (~x) + 51;
}

typedef unsigned long long ull;
const int g = 6;
const int mod = (1 &lt;&lt; g) - 1;
ull BUFF[1 &lt;&lt; 25], *BT = BUFF + sizeof(BUFF) / sizeof(ull);//预先开好内存池
inline ull *alloc(int sz){return BT -= sz;}//动态分配空间
struct Trie{
    int dep;ull *a[5];//动态数组
    Trie(int sz){//初始化
        dep = 1;
        for(;;++ dep){
            int cnt = (sz + (1ull &lt;&lt; g * dep) - 1) &gt;&gt; g * dep;//表示这一层有多少个点
            a[dep - 1] = alloc(cnt);
            if(cnt == 1) return ;
        }
        //注意这里层数越小越深，这样方便我们位运算
    }
    inline void ins(int x){
        for (int i = 0;i &lt; dep;++ i){//自下而上遍历的
            ull p = 1ull &lt;&lt; (x &gt;&gt; i * g &amp; mod); //判断我们这个 x 在当前这一层要走哪一条边，并且直接左移好方便压位的处理
            if(a[i][x &gt;&gt; (i + 1) * g] &amp; p) return ;//剪枝，上面有就可以弹出了
            a[i][x &gt;&gt; (i + 1) * g] |= p;
        }
    }
    inline void del(int x){
        for (int i = 0;i &lt; dep;++ i)
            if(a[i][x &gt;&gt; (i + 1) * g] &amp;= ~(1ull &lt;&lt; (x &gt;&gt; i * g &amp; mod))) return ;//删除一个位置，同样是删完还有就不删了的剪枝
    }
    inline int succ(int x){
        for (int i = 0;i &lt; dep;++ i){
            int cur = (x &gt;&gt; i * g) &amp; mod;ull v = a[i][x &gt;&gt; (i + 1) * g];//当前是哪一条边，由于这里只需要知道是哪一条边所以我们不需要左移
            if(v &gt;&gt; cur &gt; 1){//如果存在前驱，也可以写成 v &gt;&gt; (cur + 1)，后者更好理解但前者似乎更快
                int res = x &gt;&gt; (i + 1) * g &lt;&lt; (i + 1) * g;
                res += (ctz(v &gt;&gt; (cur + 1)) + cur + 1) &lt;&lt; i * g;//先把这一层的贡献加上，注意是不完整的
                for (int j = i - 1;~j;-- j) res += ctz(a[j][res &gt;&gt; (j + 1) * g]) &lt;&lt; j * g;//剩下每一层都是完整的
                return res;//直接返回
            }
        }
        return 0;//否则返回零
    }
    inline int pre(int x){//与上面同理，不赘述
        for (int i = 0;i &lt; dep;++ i){
            int cur = (x &gt;&gt; i * g) &amp; mod;ull v = a[i][x &gt;&gt; (i + 1) * g];
            if(v &amp; ((1ull &lt;&lt; cur) - 1)){
                int res = x &gt;&gt; (i + 1) * g &lt;&lt; (i + 1) * g;
                res += (mod - clz(v &amp; ((1ull &lt;&lt; cur) - 1))) &lt;&lt; i * g;
                for (int j = i - 1;~j;-- j) res += (mod - clz(a[j][res &gt;&gt; (j + 1) * g])) &lt;&lt; j * g;
                return res;
            }
        }
        return 0;
    }

};

int ans;
Trie s(1 &lt;&lt; 30);
inline void work(){
    int x = GenHelper :: rand_() &amp; ((1 &lt;&lt; 30) - 1), op = (x &gt;&gt; 15) &amp; 3;
      /* Your code begins here */
    if(op == 0) s.ins(x);
    else if(op == 1) s.del(x);
    else if(op == 2) ans ^= s.pre(x);
    else ans ^= s.succ(x);
}
int n, seed;
int main(){
    scanf(&quot;%d%d&quot;, &amp;n, &amp;seed);
    srand_(seed);
    while(n --) work();
    printf(&quot;%d\n&quot;, ans);
}
</code></pre>

</details>


<h2 id="3-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93">3 个人总结</h2>
<p>这个数据结构似乎都基于值域，而且似乎使用起来有比较大的限制，所以感觉在我目前能够涉及到的 OI 范围中不太能用上，比如论文里面给出的 <strong>[ZJOI2019] 语言</strong> 这一例子，我们完全可以使用线段树合并来进行直接处理，代码难度更低的同时同样可以通过这道题。故个人感觉除了卡常需要，这个数据结构一般不太会用上。不过这个思想还是很值得学习的。</p>

            

        </div>

    </div>
</body>