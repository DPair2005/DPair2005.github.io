---
title: Ynoi 做题记录 III
tags:
  - ds
  - wys
  - sqrt
  - lxl
  - solution
---

41、[P7897 [Ynoi2006] spxmcq](https://www.luogu.com.cn/problem/P7897)

标签：扫描线

其实挺套路的。

我们首先考虑设当前的询问是 $x$，然后考虑 $O(nm)$ 的暴力 DP。

发现式子是：
$$
f_u=a_u+x+\sum_{u\to v}\max(f_v, 0)
$$
然后我们考虑怎么算这个东西。

我们考虑建一个森林。对于每一个原树的状态，只对所有满足 $f_u \ge 0$ 的点连一条连向原树上父亲的边，那么就能得到一个森林。显然我们只会不断加边。

然后我们意识到如果我们对这个森林跑刚才的 DP，只需要这样：
$$
f_u=a_u+x+\sum_{u\to v} f_v
$$
注意到这个式子就是加上 $x$ 之后的子树和，其实就是这个子树不加 $x$ 的子树和加上 $x$ 乘上子树大小。那么我们只要能够对于每一个 $x$ 快速求出子树形态，基本上就能快速处理这个东西了。

然后我们考虑把 $x$ 递增排序，那么显然 $f_u$ 也是单调递增的。

因此对于每一个点 $\max(f_v, 0)$ 是取 $f_v$ 还是 $0$ 显然只会变化一次。

因此每一条边只会从 **断** 变成 **连** 一次，只要能够快速找到所有这样的边即可。

考虑维护一个 `std::set`，每一个点对应一个权值 $val$ 表示 $x\ge val$ 时这个点是取 $f_u$ 的，

然后考虑这个 $val$ 是什么，我们显然可以列一个方程：

$$
sz\times val+sum\ge0
$$
因此
$$
val= \lceil\frac{sum}{sz}\rceil
$$

其中 $sz, sum$ 分别表示子树大小和子树和。

考虑我们每连一条边，都只会改变集合中 $\mathcal{O}(1)$ 个元素的这两个值，而且在原树上相当于一个链修改。

因此我们再加上一个单点修改区间查询的数据结构就行了。

得到复杂度 $\mathcal{O}((n+m)\log n)$。

~~有没有更优做法我就不知道了，但我确实是压线过去的。~~

42、[P7906 [Ynoi2005] rpxleqxq](https://www.luogu.com.cn/problem/P7906)

标签：大屑题，垃圾题，傻逼题，Ynoi 之耻

~~出题人题解.jpg~~

首先看到二元组想到二离，可以转化为一个 $O(n)$ 次修改 $O(n\sqrt{m})$ 次查询的问题。

修改方式是向集合中插入一个点，查询方式是给出一个数 $x$ 和一个固定的常数 $y$ ，求集合内有多少个数 $z$ 满足 $z \oplus x \le y$。

考虑对 $z$ 建 Trie ，按 $x, y$ 的当前位进行讨论。

具体讨论不展开了，反正一定是 “对一棵子树累加贡献然后进入另一棵子树” 的形式。

然后考虑把 $k$ 层决策压成一层，那么如果能做到每一层 $O(1)$ 查询，一次查询就是 $O(\frac{\log n}{k})$ 的。

然后考虑修改部分，我们对于每 $k$ 层直接枚举 $x, y$ 在这几位的的 $4^k$ 种可能性（如果 $y$ 固定那就是 $2^k$） ，因此取 $k= \frac{\log n}{4}$ 即可得到 $O(\sqrt{n})-O(1)$ 的一个结构。

然后就做完了，大水题，又水又垃圾。

43、[P5073 [Ynoi2015] 世上最幸福的女孩](https://www.luogu.com.cn/problem/P5073)

标签：计算几何

第臭名昭著分块的严格弱化版

考虑一般性的最大子段和做法，显然这里不能动态 dp

因此考虑用前缀和后缀和区间最大子段和那一套来做

显然这里是一个函数的形式，相当于这三个信息是三个分段函数

考虑都是 $f(x)=kx+b$ 的形式，然后每一次 $x$ 不同

因此套用斜率优化那一套理论，建立形如 $(k,b)$ 的一些点。

考虑合并，显然除了 $m=\max\\{l, r\\}$ 这一部分剩下的都可以直接取 $\max$。

考虑这一部分是形如 $g(x\_1+x\_2)=f\_1(x\_1)+f\_2(\_2)$ 的形式，因此直接闵可夫斯基和就行。

然后考虑询问离线，那么就有单调性了。

因此最终时空复杂度 $\mathcal{O}(n\log n)$。

~~所以这玩意儿怎么今天还是黑的~~

43、[P7898 [Ynoi2006] wcirq](https://www.luogu.com.cn/problem/P7898)

标签：构造？交互？

考虑我们其实就是要设计一个数据结构，使得它恰好覆盖某段区间且支持单点插入。

然后它要保证 Worst Case，说人话就是跑的最慢的一组不能很慢。

还注意到它不支持快速合并。

因此我们毙掉了所有均摊复杂度的数据结构，所有需要快速合并的数据结构。

~~（lxl：这个就是对应 worst case 的带插入区间kth的那个外层平衡树）~~

注意到查询的时候访问的节点数允许达到 $256$，因此想想它是不是会有地方不平衡。

我们这么设计：

首先考虑它要支持的是覆盖区间，因此默认它是一个 leafy 结构，具体是 WBLT 还是 skiplist 什么的再说。

我们暂时假装这个结构是个线段树，那么每一次插入基本上就是 $\mathcal{O}(\log n)$ 级别的，但是有一个问题就是某一个节点内元素过多时要分裂。

我们注意到我们一般均摊的方法都是把后面一次特别久的修改所多花的时间用前面少花的时间去替代。

但是我们这里不能直接均摊复杂度，因此我们要考虑用某种方式，来直接均摊每一次的操作数量。

换言之，对于某一次未来的操作，我们要提前把它给处理掉一部分，这样未来做那一次操作的时候就不至于耗时太久。

这里的这个操作显然就是对于插入过多的节点的分裂操作，我们发现它应该是每 $\mathcal{O}(len)$ 次插入就话费 $\mathcal{O}(len)$ 的代价去重构，因此均摊复杂度是对的。

考虑均摊其操作，假设一个节点长度的上界是 $2u$ 而原长是 $u$，我们可以考虑在它长度为 $1.5u$ 的时候每一次新的操作修改它本身和它未来的左右儿子。

这样就能摊掉一些操作了，这样可能会有

**咕咕咕咕咕咕**
