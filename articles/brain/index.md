---
title: 杂题选做
tags:
  - solution
---

主要是我觉得做完题还是得写写题解（（

### [CF1025D Recovering BST](https://www.luogu.com.cn/problem/CF1025D)

给你一个序列，问你能否对其构建一棵二叉搜索树，使得有边相连的节点都不互质。

$n \le 700$

[{MDEXPAND 具体解法

首先有一个朴素的 dp， 是 $\mathcal{O}(n^4)$ 的

注意到它要多次枚举儿子所以多了一个 $\mathcal{O}(n)$，但也导致了重复运算

因此考虑换一个方向，由儿子确定父亲，或者说在儿子处就确定好一些东西

具体来说，我们在父亲处的做法是枚举所有可能的根，然后对应这个根枚举所有可能的儿子区间及其对应的根，这样我们要枚举两次根

但是我们注意到在儿子处枚举时，其父亲节点可能的根不是 $l-1$ 就是 $r+1$，因此可以少枚举一次根

这样子的话就可以省一维

还是比较有启发性的

}]

### [CF449D Jzzhu and Numbers](https://www.luogu.com.cn/problem/CF449D)

给你一个可重集合，问你有多少个方案选出一个非空子集使得其按位与的结果为 $0$。

$n, a \le 10^6$

[{MDEXPAND 具体解法

我们考虑朴素的做法，列出其方程：

$$
\begin{aligned}
f_{i,S}&=f_{i-1,S}+\sum_{j \operatorname{and} a_i=S} f_{i-1,j} \\
&=f_{i-1,S}+\sum_{j \operatorname{and} k=S} f_{i-1,j} \times [k=a_i]
\end{aligned}
$$

注意到这是一个与卷积的形式，因此考虑 FWT。

然而暴力的 FWT 复杂度还是不对，不过注意到每一次 FWT 前只有 $a\_i$ 这一位是 $1$。

手模一下 FWT 的过程不难发现， FWT 之后每一位仍然最多是 $1$，因此卷起来之后所有为 $1$ 的位置的 $f$ 都会翻倍。

因此我们考虑把所有 FWT 的过程加起来一起算，那么每一位的最终结果就是 $2^x$。

然后还要 FWT 回去，最终答案就是 $f\_0$。

另外注意到全 $0$ 的时候会多算一个空集，去掉就好。

复杂度 $\mathcal{O}(n\log n)$。

}]

### [CF1453F Even Harder](https://www.luogu.com.cn/problem/CF1453F)

给定数组 $a$，$a_i$ 表示从 $i$ 能走到 $\[i+1, i+a\_i\]$，问至少要把多少个 $a\_i$，改成 $0$，才能使得 $1$ 到 $n$ 有且仅有一条路径。

$n \leq 3000$。

[{MDEXPAND 具体解法

一眼 DP，然后发现直接处理 $a$ 序列不是很好搞。

注意到最终只剩下一条路径，因此可以直接对最后的跳跃序列跑 DP。

考虑设 $f_{i,j}$ 表示 $i, j$ 为跳跃序列最后两个元素要删除的 $j$ 之前的点的个数。

考虑转移：（默认 $i$ 能到达 $j$，不能到达直接设为 $\infty$）

$$
f_{i,j}=\min_{k\in[1,i)\land j>(a_k+k)}\{f_{k,i}\}+\sum_{p=i+1}^{j-1}[p+a_p\ge j]
$$

这个式子显然 $\mathcal{O}(n^3)$，因此考虑优化。

后面一项很好处理，我们考虑前一项的处理方式。

然后我们考虑 $k$ 合法的条件，首先发现 $k$ 是一个 $[1,i)$ 区间内的前缀。

我们考虑枚举 $k$，然后拿它对所有 $j > (a\_k+k)$ 产生贡献，注意到这是一个后缀。

因此可以考虑在对应的 $(a\_k+k)+1$ 上打上 tag 然后用前缀 $\min$ 的方式贡献所有合法的位置。

最后递推地把第二项加上就行，复杂度 $\mathcal{O}(n^2)$。

}]

### [CF1085D Minimum Diameter Tree](https://www.luogu.com.cn/problem/CF1085D)

给你一棵 $n$ 个节点的树，你有一个数 $s$。

你要给每一条边分配一个边权，保证边权为 **正实数**，使得边权之和为 $s$。

最小化直径。

$n \le 10^5$

[{MDEXPAND 具体解法

显然直径产生于两个叶子之间。

我们要做的是尽可能的把边权均摊掉，因此我们不妨随便取一个点作为根然后看看贪心策略。

注意到如果一条边不连接叶子，那么它会使得多个叶子深度增加，这显然没有取在与叶子相连的边上优。

因此答案就是 $s$ 平均分给每一个叶子的返祖边，然后 $\times 2$ 即可。

}]

### [CF1526D Kill Anton](https://www.luogu.com.cn/problem/CF1526D)

给定一个字符串a，你可以任意打乱a中字符的顺序，记打乱后的字符串为b。记b的价值为将b转换为a所需的最小交换次数（交换指交换两个相邻元素）。输出b使得b的价值最大。

若有多种答案，任意输出一种。

[{MDEXPAND 具体解法

首先有个结论是答案中相同的字符相邻严格不劣。

那么做已经很好做了，直接枚举全排列求个逆序对取个 $\max$ 就行。

假设原序列中只有两种字符，显然这个结论可以扩展到多种字符时。

考虑此时交换次数是什么，我们不妨选择其中一个字符为关键字符 $key$，那么答案就是两个序列的这玩意儿：
$$
\sum_{i=1}^n[a_i=key]\times \left(\sum_{j=i+1}^n [a_i\ne key]\right)
$$
的差值的绝对值。

显然这东西的上下界是就是所有相同字符相邻的那两种情况，显然存在其中一种与原序列差值最大。

}]

### [AT2005 [AGC003E] Sequential operations on Sequence](https://www.luogu.com.cn/problem/AT2005)

一串数，初始为 $1\sim n$，现在给 $Q$ 个操作，每次操作把数组长度变为 $q_i$，新增的数为上一个操作后的数组的重复。问 $Q$ 次操作后 $1\sim n$ 每个数出现了多少次。

$n, Q \le 10^5$

[{MDEXPAND 具体解法

首先注意到 $a\_i \ge a\_{i+1}$ 的位置没有意义，因此可以考虑把序列缩成一个上升子序列。

考虑每一项就是上一项翻几倍然后多出来一小节，翻倍可以考虑从后往前逆推，最后求出最后一项到底是第一项翻了几倍。

然后考虑多出来的一小节，我们考虑直接把它截下来然后插入到序列当中，那么只需要找到它的前驱即可，具体实现的时候可以直接暴力递归。

注意到每一次这一小节都是对上一项取模，因此最多 $\mathcal{O}(\log n)$ 次，总复杂度就是 $\mathcal{O}(\log^2 n)$。

}]

### [P4747 [CERC2017]Intrinsic Interval](https://www.luogu.com.cn/problem/P4747)

给定一个长度为 $n$ 的排列，有 $q$ 组询问，每次询问一个区间，求一个最小的区间使得该区间包含询问区间且值域上连续，输出区间长度。

$n, q \le 10^5$

[{MDEXPAND 具体解法

}]
