 

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="/css/main.css">
  <link rel="stylesheet" type="text/css" href="/css/art.css">
  <link rel="icon" type="images/png" href="/images/favicon.png">
  <script src="/js/element.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.4.0/build/styles/atom-one-light.min.css">
  <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.4.0/build/highlight.min.js"></script>
</head>

<body>
  <script>
    window.onload = function() {
      loadMath();
      drawSaying();
      hljs.configure({ tabReplace: '  ' });
      hljs.initHighlighting()
    }
  </script>

  <div class="content">
    <div class="sidebar" id="sidebar">
      <title>
          浅谈一类 “暴力” 在 OI 中的应用——莫队
      </title>
      <script>
  SaveBackground()
</script>
<div class="sidebar-title">
  <p style="font-weight: bold; font-size: 25px; font-family: 'ZCOOL XiaoWei';" onclick="drawSaying()"> 

DPairの非自制 blog
    <HR align="center" style="width: 200px;">
  </p>
    <div font="" style="text-align: center; font-size: 18px; font-family: 'ZCOOL XiaoWei';" class="sayingtype" id="sayingtype"> </div>
    <div font="" style="text-align: center; font-size: 6px;"> 　 </div>
  <div class="saying" id="saying"> </div>
</div>
<div class="sidebar-body">

  <div class="sidebar-content">
    <ul class = "sidebar-menu">
      <a href="/">
        <li class="list-item sidebar-menu-item" id="sidebar-content-home">
          Home
        </li>
      </a>
      <a href="/articles">
        <li class="list-item sidebar-menu-item" id="sidebar-content-articles"
            style="background: #e5e5e5">
          Articles
        </li>
      </a>
      <a href="/transit">
        <li class="list-item sidebar-menu-item" id="sidebar-content-Transit">
          Transit
        </li>
      </a>
      <a href="/tags">
        <li class="list-item sidebar-menu-item" id="sidebar-content-tags">
          Tags
        </li>
      </a>
    </ul>
  </div>

  <div class="sidebar-about">
    <div style="text-align: center; font-size: 16px;"> About DPair </div>
    <HR align="center">
      <div style="margin: 2 auto; width: min-content">
          <img class="avatar" alt="DPair" src="/images/avatar.png" onclick="NextBackground()">
        </div>
    <ul class="sidebar-links">

<li class="sidebar-links-item">
    <a href="https://www.luogu.com.cn/blog/DPair2005/" class="friend-link"> 
      luogu blog 
    </a>
  </li>
<li class="sidebar-links-item">
    <a href="https://codeforces.com/profile/DPair" class="friend-link"> 
      Codeforces 
    </a>
  </li>
<li class="sidebar-links-item">
    <a href="https://atcoder.jp/users/DPair" class="friend-link"> 
      AtCoder 
    </a>
  </li>
<li class="sidebar-links-item">
    <a href="https://gitee.com/DPair" class="friend-link"> 
      gitee 
    </a>
  </li>
<li class="sidebar-links-item">
    <a href="https://github.com/DPair2005" class="friend-link"> 
      github 
    </a>
  </li>
<li class="sidebar-links-item">
    <a href="mailto:DPair2005@163.com" class="friend-link"> 
      mail 
    </a>
  </li>

    </ul>
  </div>

  <ul class="sidebar-links">
    <div style="text-align: center; font-size: 16px;"> Friend Links </div>
    <HR align="center">

<li class="sidebar-links-item">
    <a href="https://www.luogu.com.cn/user/140572" class="friend-link"> 
      DSair
    </a>
  </li>
<li class="sidebar-links-item">
    <a href="https://coderoj.gitee.io/" class="friend-link"> 
      Jacderzhang's blog
    </a>
  </li>
<li class="sidebar-links-item">
    <a href="https://xyix.gitee.io/" class="friend-link"> 
      xYix's blog
    </a>
  </li>
<li class="sidebar-links-item">
    <a href="https://www.cnblogs.com/Flying2018/" class="friend-link"> 
      Flying2018's blog
    </a>
  </li>
<li class="sidebar-links-item">
    <a href="https://www.cnblogs.com/-Wallace-/" class="friend-link"> 
      _Wallace_'s blog
    </a>
  </li>
<li class="sidebar-links-item">
    <a href="https://www.cnblogs.com/Point-King/" class="friend-link"> 
      Point_King's blog
    </a>
  </li>

  </ul>

</div>

    </div>

    <div class="post" id="post">
      <h1 id="%E6%B5%85%E8%B0%88%E4%B8%80%E7%B1%BB-%E2%80%9C%E6%9A%B4%E5%8A%9B%E2%80%9D-%E5%9C%A8-oi-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E8%8E%AB%E9%98%9F">浅谈一类 “暴力” 在 OI 中的应用——莫队</h1>
<p>//20210206update：树上莫队中关于欧拉序的描述出现偏差，修锅。</p>
<p>//20201225update：更改了一些不必要的或错误的言论，感谢神仙lxl的指出。</p>
<h2 id="-4-%E6%AF%94%E6%AF%94%E5%89%8D%E8%A8%80%E8%BF%98%E8%A6%81%E5%89%8D%E8%A8%80%E7%9A%84%E5%89%8D%E8%A8%80%E8%BF%98%E8%A6%81%E5%89%8D%E8%A8%80%E7%9A%84%E5%89%8D%E8%A8%80">-4 比比前言还要前言的前言还要前言的前言</h2>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/n75fkqkc.png" alt=""></p>
<p>这篇博客的字数统计</p>
<h2 id="-3-%E6%AF%94%E5%89%8D%E8%A8%80%E8%BF%98%E8%A6%81%E5%89%8D%E8%A8%80%E7%9A%84%E5%89%8D%E8%A8%80">-3 比前言还要前言的前言</h2>
<p>本文不考虑在线化莫队，并认为那是一种分块</p>
<h2 id="-2-%E5%89%8D%E8%A8%80">-2 前言</h2>
<p>刚学完二次离线莫队，稍微整理一下莫队这个算法。</p>
<p>本人版权意识薄弱。。。</p>
<h2 id="-1-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">-1 前置知识</h2>
<ul>
<li><p>多关键字排序</p>
</li>
<li><p>循环</p>
</li>
<li><p>*LCA（最近公共祖先），这个应该就树上莫队会用到</p>
</li>
<li><p>可能需要一些基础分块思想</p>
</li>
</ul>
<p>没错如果这些都会了那你就可以愉快的学习莫队了。</p>
<p>注：本文无特殊说明默认 $n,m$ 同阶，其他的请自行具体情况具体分析。</p>
<h2 id="0-%E6%9A%B4%E5%8A%9B">0 暴力</h2>
<h3 id="0-1-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B">0-1 算法简介</h3>
<p>在开始之前，我们先学习一种叫 “暴力” 的<del>优秀算法</del>。</p>
<p>暴力，顾名思义就是题目让你做什么你就做什么，不加任何优化也不做过多思考。</p>
<p>比如这样一道题。</p>
<h3 id="0-2-%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90">0-2 例题分析</h3>
<h4 id="%E4%BE%8B1%EF%BC%9A">例1：</h4>
<p><a href="https://www.luogu.com.cn/problem/P2709">P2709 小B的询问</a></p>
<h5 id="%E3%80%90%E9%A2%98%E6%84%8F%E7%AE%80%E8%BF%B0%E3%80%91">【题意简述】</h5>
<p>给你一个长度为 $n$ 的序列 $a$ ，$a[i] \in [1,k]$，有 $m$ 次询问，每一次询问一个区间 $[l,r]$ 中 $\sum_{i=1}^k c_i^2$ 的值， $c_i$ 表示 $i$ 在 $[l,r]$ 中的出现次数。</p>
<h5 id="%E3%80%90%E6%80%9D%E8%B7%AF%E3%80%91">【思路】</h5>
<p>考虑暴力枚举，每一次暴力扫一遍整个区间，对于遇到的每一个 $a_i$ ，我们使得 $c_{a_i}\gets c_{a_i} + 1$ ，最后暴力求出 $\sum_{i=1}^k c_i^2$ 即可。</p>
<p>复杂度 $O(m(n+k))$ 。<del>非常优秀</del></p>
<p>显然过不去。</p>
<p>我们考虑怎么优化这个算法。</p>
<p>不难发现，我们执行 $c_{a_i}\gets c_{a_i} + 1$ 操作时，我们已经可以考虑最终答案会怎么变化，不难发现当 $c_{a_i}\gets c_{a_i} + 1$ 时，答案会增加 $2c_{a_i}+1$ （这里的 $c_{a_i}$ 是未变化前的）。</p>
<p>因此我们每一次 $c_{a_i}\gets c_{a_i} + 1$ 时可以直接更新答案，复杂度现在与 $k$ 无关了，为 $O(nm)$ 。</p>
<p>然后我们不难发现我们经常会算重一些区间，比如 $[1,10]$ 和 $[2,11]$ 的差距其实是不大的。</p>
<p>那么我们考虑算完 $[1,10]$ 之后，算 $[2,11]$ 时把 $a_1$ 的贡献去掉 $a_{11}$ 的贡献加上，就是 $[2,11]$ 的答案了，我们可以把这个操作看成移动区间的端点。</p>
<p>那么怎么减去贡献呢？</p>
<p>其实和加是差不多的。</p>
<p>和 $c_{a_i}\gets c_{a_i} + 1$ 类似， $c_{a_i} \gets c_{a_i} - 1$ 时我们只需要考虑答案会减少多少，不难发现减少的也是 $2c_{a_i}+1$ （然而这里 $ c_{a_i}$ 是变化后的），然后我们就可以通过上一个询问更新出下一个询问的答案了，具体这么实现：</p>
<pre><code class="lang-cpp">while(l &gt; q[i].l) add(a[-- l]);
while(r &lt; q[i].r) add(a[++ r]);
while(l &lt; q[i].l) del(a[l ++]);
while(r &gt; q[i].r) del(a[r --]);
</code></pre>
<p>其中 <code>add(x)</code> 表示加入一个 <code>x</code> 并计算贡献，对应的， <code>del(x)</code> 表示删去一个 <code>x</code> 并计算贡献。</p>
<p>但是复杂度仍然没有变化，因为上面所说的这个算法是可以被卡到 $O(nm)$ 的。</p>
<p>那么我们就想一想这个算法怎么才能不被卡。</p>
<p>于是莫队算法应运而生。</p>
<h2 id="1-%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F">1 普通莫队</h2>
<h3 id="1-1-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B">1-1 算法简介</h3>
<p>下面我们简单介绍一下莫队算法。</p>
<p>其核心思维就是对于 <strong>区间查询</strong> 操作，通过对所有 “被询问的区间进行” <strong>合理的排序</strong> ，然后通过 <strong>暴力移动区间的左右端点</strong> 并 <strong>快速更新答案</strong> 得到所有询问的结果。</p>
<p>是不是挺绕的？我们来看一道例题。</p>
<h3 id="1-2-%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90">1-2 例题分析</h3>
<h4 id="%E4%BE%8B1%EF%BC%9A">例1：</h4>
<p><a href="https://www.luogu.com.cn/problem/P2709">P2709 小B的询问</a></p>
<p><del>没错我又回来了</del></p>
<h5 id="%E3%80%90%E9%A2%98%E6%84%8F%E7%AE%80%E8%BF%B0%E3%80%91">【题意简述】</h5>
<p>给你一个长度为 $n$ 的序列 $a$ ，$a[i] \in [1,k]$，有 $m$ 次询问，每一次询问一个区间 $[l,r]$ 中 $\sum_{i=1}^k c_i^2$ 的值， $c_i$ 表示 $i$ 在 $[l,r]$ 中的出现次数。</p>
<h5 id="%E3%80%90%E6%80%9D%E8%B7%AF%E3%80%91">【思路】</h5>
<p>刚才我们已经学会了这道题暴力怎么做，并且我们也明白了怎么暴力移动区间端点。</p>
<p>那么怎样我们才能使得复杂度正确呢？</p>
<p>首先，我们把这个序列分成很多长度相同的块，每一块长度设为 $b$ 。</p>
<p>然后对于所有 <strong>左端点在同一个块里的询问</strong> ，我们按它们的 <strong>右端点升序排序</strong> ， 否则我们按它们的 <strong>左端点升序排序</strong> ，具体为什么这么写一会儿会讲。</p>
<p>这部分代码如下：（其中 <code>idb(x)</code> 表示 <code>x</code> 在第几个块里）</p>
<pre><code class="lang-cpp">inline int idb(int x){return x / b;}
struct QUEST{//表示一个询问
    int l, r;
    int id;//表示这个询问是第几个，由于询问在排序后顺序会乱掉，我们要存储其原先的询问顺序。
    inline bool operator &lt;(const QUEST &amp;tmp) const{
        return (idb(l) != idb(tmp.l)) ? l &lt; tmp.l : r &lt; tmp.r;
    }
}q[50005];
</code></pre>
<p>接下来我们来分析一下为什么这样子会跑的很快。</p>
<p>首先我们知道我们移动左右端点复杂度是 $O(1)$ 。</p>
<p>首先我们对于每一个块，由于所有左端点在一起的询问被排序到了一起，那么这一部分左端点做多移动 $b$ 次，<strong>一次询问</strong> 复杂度是 $O(b)$ 的，由于我们有 $m$ 个询问所以 <strong>总体</strong> 复杂度是 $O(mb)$ 的。</p>
<p>然后考虑右端点，由于右端点单调递增，所以只会往右移动，那么最多移动 $n$ 次，由于有 $n \over b$ 个块，所以 <strong>总体</strong> 复杂度是 $O({n^2 \over b})$ 的。</p>
<p>那么最终整道题的复杂度是 $O(mb+{n^2 \over b})$ 的。</p>
<p>但是， $b$ 的值其实是我们自己来确定的。</p>
<p>显然当 $mb={n^2\over b}$ 时，这道题拥有最优的复杂度。</p>
<p>那么我们就得到了 $b^2={n^2 \over m}$ ，显然 $b=\sqrt{{n^2 \over m}}$</p>
<p>由于 $n, m$ 同阶（通俗来讲就是数据范围一样），我们假设 $n=m$ ，那么 $b=\sqrt{n}$ 时复杂度最优。</p>
<p>最终复杂度就变成了 $O(n\sqrt{n})$ 远远优于刚才的复杂度。</p>
<h3 id="1-3-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">1-3 算法流程</h3>
<p>不难发现我在用莫队解刚才那一道题目的时候与原题似乎没有任何关系。</p>
<p>可见这其实就是莫队的一个通法。</p>
<p>算法大概遵循一个这样的流程：</p>
<p>1.对于所有区间端点的移动，我们要设计出一种 $O(1)$ 的方法使得我们可以快速维护移动端点后一个区间的答案。</p>
<p>2.有了这种方法之后，我们根据刚才的复杂度分析，我们对整个序列分块，每一块大小 $O(\sqrt{n})$ 。</p>
<p>3.然后我们对所有询问的区间排序，排序完之后左端点每一次最多移动 $\sqrt{n}$ 的距离总共 $n$ 次，右端点单调不降所以每一个块移动 $n$ 的距离总共 $\sqrt{n}$ 次，所以总复杂度为 $O(n\sqrt{n})$ 。</p>
<p>最后全部输出即可。</p>
<h3 id="1-4-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96">1-4 算法优化</h3>
<p>其实可以加一个小小的优化。</p>
<p>不难发现，排序的时候，我们每一个块都是按右端点升序排序的，这里显然只需要保证右端点单调就行了，所以降序排序也是对的。</p>
<p>然后我们又不难发现，每一次我们处理完左端点在某一个块中的所有询问后，右端点此时应该在序列的靠右端，处理下一个块时又回到最左端了，然后又不断往右，有一些浪费。</p>
<p>所以我们考虑引入“奇偶块排序”，即对于左端点编号为奇数的块升序，左端点编号为偶数的块降序排序。</p>
<p>于是实现变成了这样：</p>
<pre><code class="lang-cpp">inline int idb(int x){return x / b;}
struct QUEST{
    int l, r;
    int id;
    inline bool operator &lt;(const QUEST &amp;tmp) const{
        return (idb(l) ^ idb(tmp.l)) ?(l &lt; tmp.l) : ((idb(l) &amp; 1)? r &lt; tmp.r : r &gt; tmp.r);//注意这里的排序发生了一些变化
    }
}q[50005];
</code></pre>
<p>是一个优化，但并不能降低算法复杂度。</p>
<h3 id="1-5-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8A%A3">1-5 算法优劣</h3>
<h4 id="%E4%BC%98%E5%8A%BF">优势</h4>
<p>1.复杂度优秀，可以处理不少区间询问的问题</p>
<p>2.实现简单，思维难度小，不容易出错</p>
<h4 id="%E5%8A%A3%E5%8A%BF">劣势</h4>
<p>1.只能离线，无法处理强制在线的问题</p>
<p>2.复杂度是 $O(n\sqrt{n})$ 而不是 $O(n\log n)$ ，有时数据范围较大则无法处理后者能处理的问题</p>
<h3 id="1-6-%E6%8E%A8%E8%8D%90%E4%B9%A0%E9%A2%98">1-6 推荐习题</h3>
<p>1.<a href="https://www.luogu.com.cn/problem/SP3267">SP3267 DQUERY - D-query</a></p>
<p>莫队的经典运用之一：区间数颜色</p>
<p>2.<a href="https://www.luogu.com.cn/problem/CF617E">CF617E XOR and Favorite Number</a></p>
<p>很套路但有一定思维难度的莫队</p>
<p>3.<a href="https://www.luogu.com.cn/problem/P3709">P3709 大爷的字符串题</a></p>
<p>莫队的应用，需要离散化</p>
<h2 id="2-%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F">2 带修莫队</h2>
<p>没想到吧，这东西还可以带修。</p>
<h3 id="2-1-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B">2-1 算法简介</h3>
<p>一般带修莫队支持的都是单点修改，我们这里也认为只支持单点修改。</p>
<p>带修莫队就是在莫队的基础上加上一维 “时间” ，然后同样对这一维度进行排序。</p>
<p>干说似乎不太行，还是引入一道例题。</p>
<h3 id="2-2-%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90">2-2 例题分析</h3>
<h4 id="%E4%BE%8B2%EF%BC%9A">例2：</h4>
<p><a href="https://www.luogu.com.cn/problem/P1903">P1903 [国家集训队]数颜色 / 维护队列</a></p>
<h5 id="%E3%80%90%E9%A2%98%E6%84%8F%E7%AE%80%E8%BF%B0%E3%80%91">【题意简述】</h5>
<p>给你一个长度为 $n$ 的序列 $a$ ，$a[i] \in [1,k]$，有 $m$ 次询问或修改，每一次询问一个区间 $[l,r]$ 中出现过多少不同的数，每一次单点修改一个数。</p>
<h5 id="%E3%80%90%E6%80%9D%E8%B7%AF%E3%80%91">【思路】</h5>
<p>如果没有修改的话，一般的莫队其实就是看端点上的数在修改后出现状态会不会发生变化，显然 “有” -&gt; “无” 会使得答案 $-1$ ，“无” -&gt; “有” 会使得答案 $+1$ 。</p>
<p>那么。。。加上修改呢？</p>
<p>我们考虑对于每一次询问记录一个时间戳 $t$ ，表示这个询问之前进行了 $t$ 次修改，那么由于修改顺序是不会变的，进行过哪些修改一目了然。</p>
<p>此时，我们在原先排序的基础上，对于所有 <strong>右端点</strong> 在同一个块中的询问按 $t$ 升序排序。</p>
<p>然后从一个区间 $([l,r],t)$ 推到 $([l&#39;,r&#39;],t&#39;)$ 时，我们考虑把 $[l,r] \rightarrow [l&#39;,r&#39;]$ 的过程先解决，然后再推 $t\rightarrow t&#39;$ ，由于我们都是单点修改，我们只需要看 $t$ 所修改的位置是否在当前区间内，如果在，则删去原有信息，加入新信息，然后直接对位置上的数进行修改即可。</p>
<p>可以这么实现：</p>
<p>其中 <code>c[x]</code> 为一个 <code>std::pair&lt;int, int&gt;</code> 类型的变量，<code>c[x].first</code> 表示修改的位置， <code>c[x].second</code> 表示修改的值。</p>
<pre><code class="lang-cpp">    while(t &lt; q[i].t){
        int tmp = a[c[++ t].first];
        a[c[t].first] = c[t].second;
        if(c[t].first &gt;= q[i].l &amp;&amp; c[t].first &lt;= q[i].r) add(a[c[t].first]);
        c[t].second = tmp;//仔细想一想为什么要交换，我不多赘述
        if(c[t].first &gt;= q[i].l &amp;&amp; c[t].first &lt;= q[i].r) del(c[t].second);     
    }
    while(t &gt; q[i].t){
        int tmp = a[c[t].first];
        a[c[t].first] = c[t].second;
        if(c[t].first &gt;= q[i].l &amp;&amp; c[t].first &lt;= q[i].r) add(a[c[t].first]);
        c[t].second = tmp;//同上
        if(c[t].first &gt;= q[i].l &amp;&amp; c[t].first &lt;= q[i].r) del(c[t].second);
        t --;
     }
</code></pre>
<p>没错，改这么一点就可以支持修改了。</p>
<p>我们来分析一下复杂度。</p>
<p>首先还是假设块长为 $b$ 。</p>
<p>然后，我们显然有 $({n\over b})^2$ 个 <strong>左端点块和右端点块形成的数对</strong> ，每一个这样的数对中 $t$ 单调递增，需要修改 $n$ 次。</p>
<p>然后这里面每一次左右端点的修改都是 $b$ 次，总共有 $n$ 组。</p>
<p>故总复杂度为 $O(n({n\over b})^2+bn)$ 。</p>
<p>显然我们要使得 $n({n\over b})^2=bn$ 。</p>
<p>得到 $n^2=b^3$ ，所以 $b=n^{2 \over 3}$ 时最优，那么总复杂度为 $O(n^{5 \over 3})$ 。</p>
<p>但至少比暴力修改要好。</p>
<h3 id="2-3-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">2-3 算法流程</h3>
<p>其实和普通莫队差不多。</p>
<p>1.设计出这道题不带修怎么莫队。</p>
<p>2.把时间戳 $t$ 加入到排序中，然后在处理询问时移动 $t$ 指针，采用一个加一个删来等效替代修改操作。</p>
<p>然后。。。其实就好了</p>
<h3 id="2-4-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8A%A3">2-4 算法优劣</h3>
<h4 id="%E4%BC%98%E5%8A%BF%EF%BC%9A">优势：</h4>
<p>1.可以支持修改，莫队又变强了。</p>
<h4 id="%E5%8A%A3%E5%8A%BF%EF%BC%9A">劣势：</h4>
<p>1.复杂度较高，无法应对大数据范围</p>
<p>2.似乎只能支持单点修改</p>
<h3 id="2-5-%E6%8E%A8%E8%8D%90%E4%B9%A0%E9%A2%98">2-5 推荐习题</h3>
<p>1.<a href="https://www.luogu.com.cn/problem/CF940F">CF940F Machine Learning</a></p>
<p>带修莫队应用</p>
<h2 id="3-%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F">3 树上莫队</h2>
<p>没想到吧，这东西还可以上树</p>
<h3 id="3-1-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B">3-1 算法简介</h3>
<p>众所周知，树上的一些数据结构问题都是把树上的问题压到一个序列上进行求解。</p>
<p>莫队也不例外，可以处理树上的问题。</p>
<p>但我们可能需要引入一些奇奇怪怪的东西。。。</p>
<h3 id="3-2-%E6%8B%AC%E5%8F%B7%E5%BA%8F">3-2 括号序</h3>
<p>我们引入一棵树的括号序，这也是一种 dfs 序，对于一棵节点数为 $n$ 的树，它的括号序为一个长度为 $2n$ 的序列，记录了对这棵树 $dfs$ 时一个点 “入搜索栈的时间戳” 与 “出搜索栈的时间戳” 。</p>
<p>比如对于这样一棵树：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/cn9vb0ip.png" alt=""></p>
<p>它的括号序就是 ${1,2,4,4,5,5,2,3,3,6,6,1}$ （可能不只一种）</p>
<p>同时我们对于每一个值记录两个下标，这里我们设 $dfn[x]$ 表示 $x$ 这个数在序列中第一次出现的位置， $low[x]$ 表示最后一次出现的位置。</p>
<p>这东西用处很多，这里只讲它在树上莫队中的用处。</p>
<h3 id="3-3-%E4%BE%8B%E9%A2%98%E5%BC%95%E5%85%A5">3-3 例题引入</h3>
<h4 id="%E4%BE%8B3%EF%BC%9A">例3：</h4>
<p><a href="https://www.luogu.com.cn/problem/SP10707">SP10707 COT2 - Count on a tree II</a></p>
<h5 id="%E3%80%90%E9%A2%98%E6%84%8F%E7%AE%80%E8%BF%B0%E3%80%91">【题意简述】</h5>
<p>给你一棵 $n$ 个节点的树，每一个点有一个颜色，每一次询问一条路径上的节点的不同颜色数。</p>
<h5 id="%E3%80%90%E6%80%9D%E8%B7%AF%E3%80%91">【思路】</h5>
<p>首先，我们已经学会了怎么在一个序列上处理这个问题。</p>
<p>现在我们考虑怎么让莫队上树。</p>
<p>先拿刚才那一棵树来说吧。</p>
<p>这需要分类讨论：（假设我们询问的是 $(u,v)$）</p>
<h6 id="1%E3%80%81-u-%E5%9C%A8-v-%E7%9A%84%E5%AD%90%E6%A0%91%E4%B8%AD%EF%BC%9A">1、$u$ 在 $v$ 的子树中：</h6>
<p>比如 $v=2, u=5$ ，我们考虑截取区间 $[dfn[v],dfn[u]]$ 即 $[dfn[2],dfn[5]]$ 。</p>
<p>这一段区间是 ${2,4,4,4}$ 。</p>
<p>其中 $4$ 出现了 $2$ 次，这是因为 $4$ 不属于这条路径，它已经进了一次搜索栈然后又出去了，这启示我们在莫队的时候要对出现两次的数进行去重，使得其没有贡献，这个我们在它出现过时 $del()$ ，未出现时 $add()$ 即可。</p>
<p>由于 $u$ 在 $v$ 的子树中，所以所有出现过两次的必然已经进过搜索栈又出了搜索栈，不在这条路径上，而剩下的只出现一次的点仍在搜索栈中，故在路径上。</p>
<h6 id="2%E3%80%81-u-v-%E6%B2%A1%E6%9C%89%E7%A5%96%E5%AD%99%E5%85%B3%E7%B3%BB">2、$u,v$ 没有祖孙关系</h6>
<p>刚才的结论有一个前提，就是 $u$ 在 $v$ 的子树中，那么对于 $u,v$ 没有祖孙关系的呢？</p>
<p>我们同样可以这么取 $[low[v],dfn[u]]$，而此时我们需要保证的是 $low[v] &lt; dfn[u]$ 。</p>
<p>为什么这是对的呢？</p>
<p>可以这么考虑：对于 $v$ 到 $lca(u,v)$ （这里指 $u, v$ 的最近公共祖先），我们不考虑其入搜索栈过程而只考虑其出搜索栈过程，那么只有 $v$ 到 $lca(u,v)$ 路径上的点是只出不进的，同样也只统计了一次，然后 $lca(u,v)$ 到 $u$ 的路径按第一种情况考虑即可。</p>
<p>然后我们发现这个区间中没有 $lca(u,v)$ ，所以这种情况中我们把它加上就是了。</p>
<p>那么这道题就做完了。</p>
<p>排序照常排，然后把 $add()$ 和 $del()$ 换成 “更改”，因为我们是要考虑一个点是否恰好出现一次才给它贡献。</p>
<p>然后数组长度是 $2n$ 不要忘了。</p>
<h3 id="3-4-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">3-4 算法流程</h3>
<p>其实也说得很清楚了。</p>
<p>1.建出这棵树的括号序并处理出 $lca$ 。</p>
<p>2.按普通莫队去跑，分类讨论子树关系，然后特判 $lca$ 的情况。</p>
<p>3.修改时注意不一定是加点或者删点，而要根据这个点的出现次数判断是加点还是删点。</p>
<h3 id="3-5-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8A%A3">3-5 算法优劣</h3>
<h4 id="%E4%BC%98%E5%8A%BF%EF%BC%9A">优势：</h4>
<p>莫队可以上树了，莫队又变强了</p>
<h4 id="%E5%8A%A3%E5%8A%BF%EF%BC%9A">劣势：</h4>
<p>暂时想不到</p>
<h2 id="4-%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F%EF%BC%88%E4%B8%8D%E5%88%A0%E9%99%A4-%E4%B8%8D%E5%A2%9E%E5%8A%A0%E8%8E%AB%E9%98%9F%EF%BC%89">4 回滚莫队（不删除/不增加莫队）</h2>
<p>没想到吧，这东西还可以只增不删或者只删不增。</p>
<h3 id="4-1-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B">4-1 算法简介</h3>
<p>顾名思义，这个莫队支持只增不删或者只删不增。</p>
<p>适用于那些 “增加和删除中有一个复杂度很大另一个复杂度很小” 的情况。</p>
<p>其实这就是普通莫队加一点点小改动而已，如果理解了普通莫队的本质那么回滚莫队其实很好懂。</p>
<h3 id="4-2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">4-2 算法流程</h3>
<p>这里我们先讲流程。</p>
<p>回滚莫队分两类，只删不增和只增不删，我们先说前者。</p>
<h4 id="1%E3%80%81%E5%8F%AA%E5%88%A0%E4%B8%8D%E5%A2%9E%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F">1、只删不增回滚莫队</h4>
<p>流程大致如下：</p>
<p>1.先按原来的莫队排序方法进行排序，但是不能使用奇偶块排序的优化，我们要求 $r$ 单调递减。</p>
<p>2.对于每一个左端点所在的块 $x$ ，我们设 $fst[x]$ 表示这个块的第一个节点，那么我们初始设一个区间 $[fst[x],n]$ ，这是一个大区间。</p>
<p>3.对于 $[l,r]$ 在同一个块内的，我们可以暴力处理。</p>
<p>4.对于 $[l,r]$ 不在同一个块里的，我们先移动右端点指针 $r$ ，由于 $r$ <strong>单调递减</strong> 所以我们只用删除。</p>
<p>5.记录此时的答案 $tmp$ ，防止到时候回溯 $l$ 节点时需要增加。</p>
<p>6.然后再移动 $l$ 指针 ，同理我们只用删除。</p>
<p>7.最后恢复 $l$ 指针，利用先前留下的 $tmp$ 。</p>
<h4 id="2%E3%80%81%E5%8F%AA%E5%A2%9E%E4%B8%8D%E5%88%A0%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F">2、只增不删回滚莫队</h4>
<p>流程大致如下：</p>
<p>1.先按原来的莫队排序方法进行排序，但是不能使用奇偶块排序的优化，我们要求 $r$ <strong>单调递增</strong>。</p>
<p>2.对于每一个左端点所在的块 $x$ ，我们设 $lst[x]$ 表示这个块的最后一个节点，那么我们初始设一个区间 $[lst[x],lst[x]-1]$ ，这是一个空区间。</p>
<p>3.对于 $[l,r]$ 在同一个块内的，我们可以暴力处理。</p>
<p>4.对于 $[l,r]$ 不在同一个块里的，我们先移动右端点指针 $r$ ，由于 $r$ 单调递增所以我们只用增加。</p>
<p>5.记录此时的答案 $tmp$ ，防止到时候回溯 $l$ 节点时需要删除。</p>
<p>6.然后再移动 $l$ 指针 ，同理我们只用增加。</p>
<p>7.最后恢复 $l$ 指针，利用先前留下的 $tmp$ 。</p>
<p>是不是和普通莫队很像？</p>
<p>区别主要在于：</p>
<p>1.每一个块分开处理，且使用不同的初始区间</p>
<p>2.$r$ 排序方向特定</p>
<p>然后你就学会了回滚莫队</p>
<p>它的复杂度显然是对的，因为每一次左端点最多还是移动 $O(\sqrt{n})$ 总共 $n$ 次，右端点还是 $O(n)$ 总共 $\sqrt{n}$ 次，总体复杂度还是 $O(n\sqrt{n})$ ，复杂度并没有下降，只是可能会增加常数。</p>
<h3 id="4-3-%E4%BE%8B%E9%A2%98%E5%BC%95%E5%85%A5">4-3 例题引入</h3>
<p>这里只举只删不增的例子</p>
<h4 id="%E4%BE%8B4%EF%BC%9A">例4：</h4>
<p><a href="https://www.luogu.com.cn/problem/P4137">P4137 Rmq Problem / mex</a></p>
<h5 id="%E3%80%90%E9%A2%98%E6%84%8F%E7%AE%80%E8%BF%B0%E3%80%91">【题意简述】</h5>
<p>有一个长度为 $n$ 的序列 $a$。</p>
<p>$m$ 次询问，每次询问一个区间内最小没有出现过的自然数。</p>
<h5 id="%E3%80%90%E6%80%9D%E8%B7%AF%E3%80%91">【思路】</h5>
<p>我们先考虑普通莫队怎么做。</p>
<p>删除操作可显然了，我们删掉一个数之后看看它的出现次数是不是 $0$ ，如果是，再和当前答案去个最小值就行了。</p>
<p>那么增加操作呢？</p>
<p>似乎很难搞，怎么搞复杂度似乎都是不对的。</p>
<p>于是回滚莫队就有其用武之地了。</p>
<p>后面其实不用多说，按照刚才回滚莫队的板子去套就行了。</p>
<h3 id="4-4-%E6%8E%A8%E8%8D%90%E4%B9%A0%E9%A2%98">4-4 推荐习题</h3>
<p>1.<a href="https://www.luogu.com.cn/problem/AT1219">AT1219 歴史の研究</a></p>
<p>不少人心目中的回滚莫队模板</p>
<p>2.<a href="https://www.luogu.com.cn/problem/P5906">P5906 【模板】回滚莫队&amp;不删除莫队</a></p>
<p>洛谷钦定的回滚莫队模板</p>
<p>3.<a href="https://www.luogu.com.cn/problem/SP20644">SP20644 ZQUERY - Zero Query</a></p>
<p>回滚莫队的应用</p>
<h2 id="5-%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF%E8%8E%AB%E9%98%9F">5 二次离线莫队</h2>
<p>没想到吧，这东西还可以再离线。</p>
<h3 id="5-1-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B">5-1 算法简介</h3>
<p>大毒瘤 lxl 发明的算法，很强（双重含义）。</p>
<p>二次离线莫队一般会被用于解决这样的问题：</p>
<p>1.可以莫队（废话）</p>
<p>2.莫队移动端点的修改复杂度比较大（比如 log）</p>
<p>这时，我们就会考虑把莫队移动的这些端点也都离线下来预处理，从而进一步优化。</p>
<p>估计因此叫做二次离线。</p>
<h3 id="5-2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">5-2 算法流程</h3>
<p>目前理解下来流程大概这样：</p>
<p>1.先跑莫队，由于是二元组形式，我们考虑把每一个点的贡献拆分成 <strong>这个点与这个点上一个点的前缀的贡献</strong> 减去 <strong>这个点与一段确定前缀</strong> 的贡献。</p>
<p>2.弄出一种数据结构，可以 $O(1)$ （或有些情况下稍劣） 查出一个点集与一个点之间的贡献，并可以 $O(\sqrt{n})$ （或有些情况下稍劣） 修改点集内的信息。</p>
<p>3.那么我们先一遍扫预处理出 <strong>这个点与这个点上一个点的前缀的贡献</strong> 这一部分的贡献，显然是 $O(n\sqrt{n})$ 的。</p>
<p>4.我们再在莫队的时候把所有需要求出的 <strong>这个点与一段确定前缀</strong> 所对应的 <strong>询问点</strong> 记录下来，由于这些点由第一次莫队处理出来所以点数为 $O(n\sqrt{n})$ 级别，我们可以选择用 <code>std::vector</code> 或其他工具把这些询问存储到对应 <strong>产生贡献</strong> 的前缀上去。</p>
<p>5.最后由于每一个前缀都要修改一次，总共有 $n$ 个前缀每一次修改 $O(\sqrt{n})$， 所以这一部分 $O(n\sqrt{n})$ ，然后处理出的 <strong>询问点</strong> 的个数也是 $O(n\sqrt{n})$ ，我们又是 $O(1)$ 询问，我们就达到了总体复杂度 $O(n\sqrt{n})$ 。</p>
<h3 id="5-2-5-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96">5-2.5 算法优化</h3>
<p>不难发现，在上面的二次离线过程中，我们存储的是一些 <strong>询问点</strong> ，但其实莫队处理出的询问点还有一个优美的性质，那就是每一次处理出的点显然都是连续的，故在 <strong>产生贡献的前缀</strong> 处，我们考虑把存储 <strong>单点</strong> 改为存储 <strong>区间</strong> ，这样一来总点数不变，但由于区间个数为 $O(n)$ 级别，而这里存点的过程又是原先的空间复杂度瓶颈，所以我们可以通过这个操作把空间减掉一个 $O(\sqrt{n})$ ，从 $O(n\sqrt{n})$ 变为 $O(n)$ 。而且在某一些题目中，若我们可以做到 $O(1)$ 修改（比如预处理），并且这个修改可以通过 $O(1)$ 区间查询的方式进行询问，那么扫完全局的复杂度甚至是 $O(n)$ 的。</p>
<p>这么干说似乎不太行，举一些栗子吧：</p>
<h3 id="5-3-%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90">5-3 例题分析</h3>
<h4 id="%E4%BE%8B5%EF%BC%9A">例5：</h4>
<p><a href="https://www.luogu.com.cn/problem/P5047">P5047 [Ynoi2019模拟赛]Yuno loves sqrt technology II</a></p>
<h5 id="%E3%80%90%E9%A2%98%E6%84%8F%E7%AE%80%E8%BF%B0%E3%80%91">【题意简述】</h5>
<p>给你一个长为 $n$ 的序列 $a$，$m$ 次询问，每次查询一个区间的逆序对数。</p>
<h5 id="%E3%80%90%E6%80%9D%E8%B7%AF%E3%80%91">【思路】</h5>
<p>显然一种很 naive 的写法是用树状数组加一个莫队去维护这个东西，然后你就得到了一个 $O(n\sqrt{n} \log n)$ 的优秀暴力。</p>
<p>然后你必然会 $\text{TLE}$ 。</p>
<p>那么我们考虑怎么给它二次离线。</p>
<p>比如我们要向右移动一个区间 $[l,r]$ 的右端点直到 $[l,r&#39;]$ 。</p>
<p>一般来说，我们是不断地去 $add(++r)$ ，然而这里 $add$ 复杂度比较大会很不优秀。</p>
<p>我们考虑把这一堆 $add$ 全部存下来。</p>
<p>不难发现，每一个 $r$ 经过的位置（记为 &quot;$R$&quot;）产生的贡献为 $[l,R-1],R$ 产生的逆序对个数。</p>
<p>我们差分一下，就变成了 $[1,R-1],R$ 的逆序对个数减去 $[1,l-1], R$的逆序对个数 </p>
<p>显然前面那一项直接树状数组跑一遍就行了。</p>
<p>后面的，我们考虑全部离线下来，把这些 $R$ 全部扔到对应的 $l-1$ 里面。</p>
<p>由于这些 $R$ 是连续的，我们直接扔一段 $[r + 1, r&#39;]$ 的区间就行了。</p>
<p>那么我们再考虑怎么预处理这一块。</p>
<p>树状数组？显然不行。</p>
<p>我们不难发现由于我们这些点都是用莫队离线出来的，点数是 $O(n\sqrt{n})$ 级别的。</p>
<p>而我们每一个 $l$ 只需要修改一次，总共是 $O(n)$ 的。</p>
<p>于是我们需要一个 $O(\sqrt{n})$ 修改， $O(1)$ 查询前缀和的东西，这个值域分块可以搞定。</p>
<p>其他三种移动应该以此类推就行了。</p>
<p>分析一下复杂度：</p>
<p>还是用刚才的例子，瓶颈显然在于 $[1,l-1],R$ 的处理上，然后第二次离线时我们修改是 $O(n\sqrt{n})$ 的，查询是 $O(n\sqrt{n})$ 的。</p>
<p>再看空间，显然每一次只会多出来 $O(1)$ 级别的连续段个数，然后值域分块也是 $O(n)$ 的，所以总空间复杂度 $O(n)$。</p>
<p>十分优秀，真的十分优秀。</p>
<h4 id="%E4%BE%8B6%EF%BC%9A">例6：</h4>
<p><a href="https://www.luogu.com.cn/problem/P4887">P4887 【模板】莫队二次离线（第十四分块(前体)）</a></p>
<h5 id="%E3%80%90%E9%A2%98%E6%84%8F%E7%AE%80%E8%BF%B0%E3%80%91">【题意简述】</h5>
<p>给你一个长度为 $n$ 的序列 $a$，每次查询给一个区间 $[l,r]$ 。</p>
<p>查询 $l \leq i&lt; j \leq r$ ,且 $a_i \oplus a_j$ 的二进制表示下有 $k$ 个 $1$ 的二元组 $(i,j)$ 的个数。$\oplus$ 是指按位异或。</p>
<h5 id="%E3%80%90%E6%80%9D%E8%B7%AF%E3%80%91">【思路】</h5>
<p>同样考虑怎么二次离线</p>
<p>首先我们知道 $k$ 是固定的。</p>
<p>然后发现值域很小，为 $2^{17}$ 的样子（后文的 $17$ 就是这么来的）。 </p>
<p>然后一般的莫队思路有两种，一种是 $O(C(17,k))$ 修改然后 $O(1)$ 查询，一种是 $O(C(17,k))$ 查询 $O(1)$ 修改，两种思路其实就都是直接枚举“所有与这个数异或后的数二进制下有 $k$ 个 $1$ 的数”，这一部分显然可以通过枚举 “所有二进制下有 $k$ 个 $1$ 的数” 然后异或上当前数得到。</p>
<p>为了二次离线，我们考虑选择前一种修改复杂度大的。</p>
<p>那么还是询问拆成两部分。</p>
<p>还是拿我们要向右移动一个区间 $[l,r]$ 的右端点直到 $[l,r&#39;]$ 来举例子。</p>
<p>不难发现，每一个 $r$ 经过的位置（记为 &quot;$R$&quot;）产生的贡献为 $[l,R-1],R$ 产生的符合条件的数的个数。</p>
<p>同样差分一下，就变成了 $[1,R-1],R$ 的数对个数减去 $[1,l-1], R$的数对个数 </p>
<p>前面那一项 $O(C(17,k))$ 修改 $O(1)$ 询问就能结束，总共 $n$ 次所以复杂度是 $O(C(17,k)n)$。</p>
<p>后面的，我们同样考虑全部离线下来，把这些 $R$ 全部扔到对应的 $l-1$ 里面。</p>
<p>由于这些 $R$ 是连续的，我们直接扔一段 $[r + 1, r&#39;]$ 的区间就行了。</p>
<p>然后还是 $O(C(17,k))$ 修改 $O(1)$ 询问，这部分复杂度是 $O(C(17,k)n+n\sqrt{n})$ 。</p>
<p>于是总复杂度变成了 $O(C(17,k)n+n\sqrt{n})$ 。</p>
<p>其实蛮套路的。</p>
<h3 id="5-4-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93">5-4 算法总结</h3>
<p>总体考虑下来，这个东西复杂度如此优秀的原因可能主要还是在于节省了修改时间，让修改次数变为了 $O(n)$ ，并同时也让空间复杂度变为了 $O(n)$ ，从而解决了询问修改都为 $O(n\sqrt{n})$ 次的普通莫队算法在修改方面的劣势，如果能设计出优秀的数据结构，可以使得总体复杂度下降为 $O(n\sqrt{n})$ 。</p>
<h3 id="5-5-%E6%8E%A8%E8%8D%90%E4%B9%A0%E9%A2%98">5-5 推荐习题</h3>
<p>1.<a href="https://www.luogu.com.cn/problem/P5501">P5501 [LnOI2019]来者不拒，去者不追</a></p>
<p>二次离线莫队简单题</p>
<p>2.<a href="https://www.luogu.com.cn/problem/P5398">P5398 [Ynoi2018]GOSICK</a></p>
<p>第十四分块</p>

      

    </div>

  </div>
</body>